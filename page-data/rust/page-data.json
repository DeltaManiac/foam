{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/rust","result":{"data":{"file":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"rust\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Rust\"), mdx(\"h2\", {\n    \"id\": \"reddit-bot\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Reddit Bot\"), mdx(\"p\", null, \"VyomBot \", mdx(\"a\", {\n    \"href\": \"/vyom\",\n    \"title\": \"vyom\",\n    \"parentName\": \"p\"\n  }, \"[[vyom]]\"), \"\"), mdx(\"h2\", {\n    \"id\": \"kafka\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Kafka\"), mdx(\"p\", null, \"Kafka [\", mdx(\"a\", {\n    \"href\": \"producer\",\n    \"title\": \"Producer\",\n    \"parentName\": \"p\"\n  }, \"Producer\"), \"]\"), mdx(\"p\", null, \"Kafka [\", mdx(\"a\", {\n    \"href\": \"consumer\",\n    \"title\": \"Consumer\",\n    \"parentName\": \"p\"\n  }, \"Consumer\"), \"]\"));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"vyom\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Vyom\"), mdx(\"p\", null, \"This bot is in [\", mdx(\"a\", {\n    \"href\": \"rust\",\n    \"title\": \"Rust\",\n    \"parentName\": \"p\"\n  }, \"rust\"), \"]\"), mdx(\"p\", null, \"Recently while browsing \", mdx(\"a\", {\n    \"href\": \"https://old.reddit.com\",\n    \"parentName\": \"p\"\n  }, \"reddit\"), \" I came up on a \", mdx(\"a\", {\n    \"href\": \"https://www.reddit.com/r/rust/comments/i1satq/webference_rusty_days_2020_all_recorded_talks/g01rwq8/?context=3\",\n    \"parentName\": \"p\"\n  }, \"post\"), \" in the \", mdx(\"a\", {\n    \"href\": \"https://old.reddit.com\",\n    \"parentName\": \"p\"\n  }, \"/r/rust\"), \" subreddit which was a link to a youtube playlist for the Rust-Wroclaw conference/meetup, however there was no way I could find the contents of the playlist without going to Youtube. This was a nuance so I went to Youtube and curated the list.\"), mdx(\"p\", null, mdx(\"img\", {\n    \"src\": \"https://dev-to-uploads.s3.amazonaws.com/i/fxof8cdxfizue63qkz7d.png\",\n    \"alt\": \"Manually listing the entries\",\n    \"parentName\": \"p\"\n  })), mdx(\"p\", null, \"This was going to be tiresome if I'd have to do it every time I see a link that is a YouTube playlist. So here we are writing a bot do this task for everyone. This bot will run on a server somewhere (hopefully forever) and curate playlist info for all the people who avail its service.\"), mdx(\"h1\", {\n    \"id\": \"creating-credentials-for-our-bot\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Creating Credentials For Our Bot\"), mdx(\"p\", null, \"In order to write our bot we first need to get some credentials from reddit so that we can access the \", mdx(\"a\", {\n    \"href\": \"https://old.reddit.com/dev/api\",\n    \"parentName\": \"p\"\n  }, \"reddit apis\"), \" programmatically.\"), mdx(\"p\", null, \"First you need an application id and secret so reddit knows your application. We can get this information by going to \", mdx(\"a\", {\n    \"href\": \"https://www.reddit.com/prefs/apps\",\n    \"parentName\": \"p\"\n  }, \"preferences/app\"), \" and clicking \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"are you a developer? create an app...\"), \" button\"), mdx(\"p\", null, \"Reddit lets us choose the type of the app we want to build. The three types of app are :\"), mdx(\"ul\", null, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Web app: Runs as part of a web service on a server you control. Can keep a secret.\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Installed app: Runs on devices you don't control, such as the user's mobile phone. Cannot keep a secret, and therefore, does not receive one.\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Script app: Runs on hardware you control, such as your own laptop or server. Can keep a secret. Only has access to your account.\"))), mdx(\"p\", null, \"More info about about the apps can be found \", mdx(\"a\", {\n    \"href\": \"https://github.com/reddit-archive/reddit/wiki/oauth2-app-types\",\n    \"parentName\": \"p\"\n  }, \"here\"), \".\"), mdx(\"p\", null, \"We choose the \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"script\"), \" type, enter a name and description for our bot, and use  the dummy url \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"http://www.example.com/unused/redirect/uri\"), \" for the redirect url.\"), mdx(\"p\", null, mdx(\"img\", {\n    \"src\": \"https://dev-to-uploads.s3.amazonaws.com/i/weyxca7xkhcnfrwo36kj.png\",\n    \"alt\": \"Create App\",\n    \"parentName\": \"p\"\n  })), mdx(\"p\", null, \"We have now created the credentials with Client Id : \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"TjC0s2uTaTHYCg\"), \" and Client Secret : \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"mrkAaWitnXLf_DiRagIRS_33cD8\"), \".\"), mdx(\"p\", null, mdx(\"img\", {\n    \"src\": \"https://dev-to-uploads.s3.amazonaws.com/i/xj0q1m7li5abg060ari6.png\",\n    \"alt\": \"Credentials\",\n    \"parentName\": \"p\"\n  })), mdx(\"h1\", {\n    \"id\": \"using-and-storing-the-credentials\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Using and Storing the credentials\"), mdx(\"p\", null, \"We can now use the credentials in our source code and use it in our code.\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-rust\",\n    \"parentName\": \"pre\"\n  }, \"# main.rs\\n\\nstatic  CLIENT_ID:&str=\\\"TjC0s2uTaTHYCg\\\";\\nstatic  CLIENT_SECRET:&str=\\\"mrkAaWitnXLf_DiRagIRS_33cD8\\\";\\n\\nfn main(){\\n    println!(\\\"Client ID: {}\\\",CLIENT_ID);\\n    println!(\\\"Client Secret: {}\\\",CLIENT_SECRET);\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-shell\",\n    \"parentName\": \"pre\"\n  }, \"DeltaManiac @ ~/git/rust/vyom\\n\\u2514\\u2500 $ cargo run\\n    Finished dev [unoptimized + debuginfo] target(s) in 0.08s\\n     Running `target/debug/vyom`\\nClient ID: SmQ7CzGkKA62yA\\nClient Secret: UItY35BYBEN_rFVnGVzud9Pig6g\\n\")), mdx(\"p\", null, \"This is a very easy and clear way to handle credentials but its flawed in two ways.\"), mdx(\"ul\", null, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"If we need to change the credentials then we would have to change the code, rebuild the app and redeploy the app.\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"If we decide to share the code with someone or push it github, it will expose our credentials, which can be used to hijack our account and do bad things.\"))), mdx(\"p\", null, \"So lets see if we can fix the first problem, by moving the credentials out of the source code. But where do we put it then ? If you're thinking about environment variables then youre absolutely right. Environment variables are a good place to store such values and they are fairly easy to change.\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-rust\",\n    \"parentName\": \"pre\"\n  }, \"# main.rs\\n\\nfn main(){\\n    match std::env::var(\\\"CLIENT_ID1\\\") {\\n        Ok(client_id) => println!(\\\"Client ID: {}\\\", client_id),\\n        Err(e) => panic!(\\\"Couldn't read CLIENT_ID ({})\\\", e),\\n    };\\n    match std::env::var(\\\"CLIENT_SECRET1\\\") {\\n        Ok(client_secret) => println!(\\\"Client Secret: {}\\\", client_secret),\\n        Err(e) => panic!(\\\"Couldn't read CLIENT_SECRET ({})\\\", e),\\n    };\\n}\\n\")), mdx(\"p\", null, \"Since our bot wont work without a \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"client_id\"), \" and a \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"client_secret\"), \" we call \", mdx(\"a\", {\n    \"href\": \"https://doc.rust-lang.org/stable/std/macro.panic.html\",\n    \"parentName\": \"p\"\n  }, \"panic!\"), \" so that the application exits with an error.\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-shell\",\n    \"parentName\": \"pre\"\n  }, \"(base) DeltaManiac @ ~/git/rust/vyom\\n\\u2514\\u2500 $ cargo run\\n    Finished dev [unoptimized + debuginfo] target(s) in 0.41s\\n     Running `target/debug/vyom`\\nthread 'main' panicked at \\\\'Couldn\\\\'t read CLIENT_ID (environment variable not found), \\nsrc/main.rs:9:19\\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\\n\\n# Set the environment variables\\n(base) DeltaManiac @ ~/git/rust/vyom\\n\\u2514\\u2500 $ export CLIENT_SECRET=UItY35BYBEN_rFVnGVzud9Pig6g\\n(base) DeltaManiac @ ~/git/rust/vyom\\n\\u2514\\u2500 $ export CLIENT_ID=SmQ7CzGkKA62yA\\n\\n(base) DeltaManiac @ ~/git/rust/vyom\\n\\u2514\\u2500 $ cargo run\\n    Finished dev [unoptimized + debuginfo] target(s) in 0.47s\\n     Running `target/debug/vyom`\\nClient ID: SmQ7CzGkKA62yA\\nClient Secret: UItY35BYBEN_rFVnGVzud9Pig6g\\n\")), mdx(\"p\", null, \"Most of the time we don't really want to export a lot of environment variables manually. Its exhausting. We could fix this problem by writing a shell script that has all our \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"export\"), \" statement... or we can use \", mdx(\"a\", {\n    \"href\": \"https://crates.io/crates/dotenv\",\n    \"parentName\": \"p\"\n  }, \"dotenv\"), \". Dotenv is a way to put environment variables in a \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \".env\"), \" file and read them. Dotenv is smart to enough to only read from the file if the Environment Variable is not set on the system.\"), mdx(\"p\", null, \"We first add the \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"dotenv\"), \" dependency to our \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"Cargo.toml\"), \" file.\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-toml\",\n    \"parentName\": \"pre\"\n  }, \"# Cargo.toml\\n[package]\\nname = \\\"vyom\\\"\\nversion = \\\"0.1.0\\\"\\nauthors = [\\\"DeltaManiac <maxpaynered@gmail.com>\\\"]\\nedition = \\\"2018\\\"\\n\\n[dependencies]\\ndotenv_codegen=\\\"0.15.0\\\" # dotenv dependency\\n\")), mdx(\"p\", null, \"We then setup the environment variables in the \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \".env\"), \" file.\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-shell\",\n    \"parentName\": \"pre\"\n  }, \"# .env\\nCLIENT_ID=test_123\\nCLIENT_SECRET=test_321\\nTest=DisTest\\n\")), mdx(\"p\", null, \"We finally modify our code to use the \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"dotenv\"), \" crate.\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-rust\",\n    \"parentName\": \"pre\"\n  }, \"# main.rs\\n\\n#[macro_use]\\nextern crate dotenv_codegen;\\n\\nfn main(){\\n    println!(\\\"Env Not on Sys: {}\\\",dotenv!(\\\"Test\\\"));\\n    println!(\\\"Client ID: {}\\\",dotenv!(\\\"CLIENT_ID\\\"));\\n    println!(\\\"Client Secret: {}\\\",dotenv!(\\\"CLIENT_SECRET\\\"));\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-shell\",\n    \"parentName\": \"pre\"\n  }, \"(base) DeltaManiac @ ~/git/rust/vyom\\n\\u2514\\u2500 $ cargo run\\n    Finished dev [unoptimized + debuginfo] target(s) in 0.08s\\n     Running `target/debug/vyom`\\nEnv Not on Sys: ss #Value from the .env file\\nClient ID: SmQ7CzGkKA62yA #Value from the system\\nClient Secret: UItY35BYBEN_rFVnGVzud9Pig6g #Value from the system\\n\")), mdx(\"h1\", {\n    \"id\": \"how-will-the-bot-work-\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"How will the bot work ?\"), mdx(\"p\", null, \"The bot will listen to a mention like \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"/u/VyomBot\"), \" and would check if the post is a link to a youtube playlist or the parent comment of the mention is a YouTube playlist.\"), mdx(\"h1\", {\n    \"id\": \"setting-up-reddit\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Setting up Reddit\"), mdx(\"p\", null, \"I've followed the following steps to setup reddit for testing/developing this bot\"), mdx(\"ol\", null, mdx(\"li\", {\n    \"parentName\": \"ol\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Created a new user called \", mdx(\"a\", {\n    \"href\": \"https://old.reddit.com/user/VyomBot\",\n    \"parentName\": \"p\"\n  }, \"VyomBot\"), \" so that the bot can be mentioned via \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"/u/VyomBot\"))), mdx(\"li\", {\n    \"parentName\": \"ol\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Registered a new app of \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"script\"), \" type for \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"/u/VyomBot\"))), mdx(\"li\", {\n    \"parentName\": \"ol\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Create a new \", mdx(\"a\", {\n    \"href\": \"https://old.reddit.com/ur/VyomBot\",\n    \"parentName\": \"p\"\n  }, \"subreddit\"), \" \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"/r/VyomBot\"), \" as a test play ground.\"))), mdx(\"p\", null, mdx(\"img\", {\n    \"src\": \"https://dev-to-uploads.s3.amazonaws.com/i/vgu4s3kk5s6bxvdrhdrh.png\",\n    \"alt\": \"/r/VyomBot\",\n    \"parentName\": \"p\"\n  })), mdx(\"ol\", {\n    \"start\": 4\n  }, mdx(\"li\", {\n    \"parentName\": \"ol\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Create a new \", mdx(\"a\", {\n    \"href\": \"https://www.reddit.com/r/VyomBot/comments/i6fk15/test_playlist/?\",\n    \"parentName\": \"p\"\n  }, \"post\"), \" with the link to the playlist.\")), mdx(\"li\", {\n    \"parentName\": \"ol\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Mention \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"/u/VyomBot\"), \" in the comments.\\n\", mdx(\"img\", {\n    \"src\": \"https://dev-to-uploads.s3.amazonaws.com/i/vriyg18m5dgc5k8rklc4.png\",\n    \"alt\": \"Alt Text\",\n    \"parentName\": \"p\"\n  })))), mdx(\"h1\", {\n    \"id\": \"talking-to-reddit\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Talking to Reddit\"), mdx(\"h2\", {\n    \"id\": \"getting-messages-from-inbox\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Getting Messages from Inbox\"), mdx(\"p\", null, \"Lets start off by querying reddit to see if we have a new mention and printing the message. We will use the \", mdx(\"a\", {\n    \"href\": \"https://crates.io/crates/roux\",\n    \"parentName\": \"p\"\n  }, \"roux\"), \" crate for interacting with the reddit apis.\\nDirect quote from the description of the crate\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    \"parentName\": \"blockquote\"\n  }, \"A simple, asynchronous Reddit API wrapper implemented in Rust.\\nThis means that we have to use a framework like \", mdx(\"a\", {\n    \"href\": \"https://crates.io/crates/tokio\",\n    \"parentName\": \"p\"\n  }, \"tokio\"), \" to provide the async runtime for our bot.\\nLets go about doing that.\")), mdx(\"p\", null, \"Add the dependencies to our Cargo.toml file.\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-toml\",\n    \"parentName\": \"pre\"\n  }, \"# Cargo.toml\\n[package]\\nname = \\\"vyom\\\"\\nversion = \\\"0.1.0\\\"\\nauthors = [\\\"DeltaManiac <maxpaynered@gmail.com>\\\"]\\nedition = \\\"2018\\\"\\n\\n[dependencies]\\ndotenv_codegen=\\\"0.15.0\\\" # dotenv dependency\\nroux=\\\"1.0.0\\\" # roux dependency\\ntokio = {version=\\\"0.2.22\\\",features=[\\\"macros\\\"]} # tokio dependency and only enable the macro feature\\n\")), mdx(\"p\", null, \"Update our code to use the library and call the reddit apis.\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-rust\",\n    \"parentName\": \"pre\"\n  }, \"# main.rs\\n\\n#[macro_use]\\nextern crate dotenv_codegen;\\n#[macro_use]\\nextern crate log; // Used for logging\\nuse roux::Reddit;\\n\\n#[tokio::main]\\nasync fn main() {\\n    match Reddit::new(\\n        dotenv!(\\\"VYOM_USERAGENT\\\"),\\n        dotenv!(\\\"VYOM_CLIENT_ID\\\"),\\n        dotenv!(\\\"VYOM_CLIENT_SECRET\\\"),\\n    )\\n    .username(dotenv!(\\\"VYOM_USERNAME\\\"))\\n    .password(dotenv!(\\\"VYOM_PASSWORD\\\"))\\n    .login()\\n    .await\\n    {   // Try to make a new client with the credentials\\n        Ok(client) => match client.inbox().await {\\n            // Fetch the inbox of the logged in user\\n            Ok(listing) => {\\n                println!(\\\"Message Count {}\\\", listing.data.children.len());\\n                dbg!(listing.data.children.get(0).unwrap());\\n            }\\n            Err(_) => {\\n                error!(\\\"Failed to fetch messages\\\");\\n            }\\n        },\\n        Err(e) => panic!(e),\\n    }\\n}\\n\\n\")), mdx(\"p\", null, \"When we run the program we get the number of messages we have and the \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"dbg!\"), \" macro shows what the passed in variable which in this case is a \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"InboxItem\"), \" struct, looks like.\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-shell\",\n    \"parentName\": \"pre\"\n  }, \"(base) DeltaManiac @ ~/git/rust/vyom\\n\\u2514\\u2500 $ cargo run\\n    Finished dev [unoptimized + debuginfo] target(s) in 3.71s\\n     Running `target/debug/vyom`\\nMessage Count 5\\n[src/main.rs:24] &listing.data.children.get(0).unwrap().data = InboxItem {\\n    id: \\\"g0vfbra\\\",\\n    subject: \\\"username mention\\\",\\n    was_comment: true,\\n    author: Some(\\n        \\\"DeltaManiac\\\",\\n    ),\\n    parent_id: Some(\\n        \\\"t3_i6fk15\\\",\\n    ),\\n    subreddit_name_prefixed: Some(\\n        \\\"r/VyomBot\\\",\\n    ),\\n    new: true, \\n    type: \\\"username_mention\\\",\\n    body: \\\"/u/VyomBot\\\",\\n    dest: \\\"VyomBot\\\",\\n    body_html: \\\"&lt;!-- SC_OFF --&gt;&lt;div class=\\\\\\\"md\\\\\\\"&gt;&lt;p&gt;&lt;a href=\\\\\\\"/u/VyomBot\\\\\\\"&gt;/u/VyomBot&lt;/a&gt;&lt;/p&gt;\\\\n&lt;/div&gt;&lt;!-- SC_ON --&gt;\\\",\\n    name: \\\"t1_g0vfbra\\\",\\n    created: 1596987973.0,\\n    created_utc: 1596959173.0,\\n    context: \\\"/r/VyomBot/comments/i6fk15/test_playlist/g0vfbra/?context=3\\\",\\n}\\n\")), mdx(\"p\", null, \"We can use the \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"new\"), \" property to identify if this is a message that we had previously read.\\nThe type property can be used to determine if the item is a comment or a username mention.\\nWe can use this to iterate over the messages retrieved and  and determine the messages that we have to reply to.\"), mdx(\"h1\", {\n    \"id\": \"replying-to-the-message\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Replying to the message\"), mdx(\"p\", null, \"Roux provides us a convenient method aptly name \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"comment\"), \" to reply to the message. Let's go ahead and use this to reply to the message.\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-rust\",\n    \"parentName\": \"pre\"\n  }, \"# main.rs\\n\\nasync fn main() {\\n...\\n...\\n// Fetch the inbox of the logged in user\\n    Ok(listing) => {\\n        for message in listing.data.children.iter() {\\n            is message unread and of type \\\"username_mention\\\"\\n            if message.data.new && message.data.r#type == \\\"username_mention\\\" {\\n                match client\\n                    .comment(\\n                        \\\"You have been Noted by Vyom. Please Stand By!\\\",\\n                        &message.data.name.as_str(),\\n                    )\\n                    .await\\n                {\\n                    Ok(_) => info!(\\\"Replied to {}\\\", message.data.name),\\n                    Err(_) => error!(\\\"Failed to reply to mention\\\"),\\n                };\\n            }\\n        }\\n    }\\n...\\n...\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    \"parentName\": \"blockquote\"\n  }, \"Psst.., I'll let you in on something cool. In rust \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"type\"), \" is a reserved keyword. In most programming languages you can use a keyword only as keyword, e.g. you \", mdx(\"em\", {\n    \"parentName\": \"p\"\n  }, \"cannot\"), \" have a variable called \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"for\"), \". In rust we can use \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"type\"), \" as an attribute of a struct and access it by specifing it as a raw string using the \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"r#\"), \" like \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"message.data.r#type\"))), mdx(\"p\", null, \"Now that we have written the code lets run it and see what happens..\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-shell\",\n    \"parentName\": \"pre\"\n  }, \"(base) DeltaManiac @ ~/git/rust/vyom\\n\\u2514\\u2500 $ cargo run\\n    Finished dev [unoptimized + debuginfo] target(s) in 4.45s\\n     Running `target/debug/vyom`\\n\")), mdx(\"p\", null, \"Nice! It logged that we replied to the mention. Lets run it again, this time it should not reply to an allready replied message as we have read it.\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-shell\",\n    \"parentName\": \"pre\"\n  }, \"[2020-08-09T12:59:25Z INFO  vyom] Replied to t1_g0vfbra\\n(base) DeltaManiac @ ~/git/rust/vyom\\n\\u2514\\u2500 $ cargo run\\n    Finished dev [unoptimized + debuginfo] target(s) in 0.10s\\n     Running `target/debug/vyom`\\n[2020-08-09T12:59:29Z INFO  vyom] Replied to t1_g0vfbra\\n(base) DeltaManiac @ ~/git/rust/vyom\\n\\u2514\\u2500 $ cargo run\\n    Finished dev [unoptimized + debuginfo] target(s) in 0.09s\\n     Running `target/debug/vyom`\\n[2020-08-09T12:59:32Z INFO  vyom] Replied to t1_g0vfbra\\n\")), mdx(\"p\", null, \"Damn! IT REPLIED AGAIN!!! And this is what the subbreddit looks like.\"), mdx(\"p\", null, mdx(\"img\", {\n    \"src\": \"https://dev-to-uploads.s3.amazonaws.com/i/fdjrhs96s7yujerdqbu8.png\",\n    \"alt\": \"replies,Replies,REPLIES\",\n    \"parentName\": \"p\"\n  })), mdx(\"p\", null, \"I guess this a good place to stop.\\nIn the next part we will find the reason for this pesky little bug and squash it.\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"797a5aeb-060e-5315-b65f-4fe1a1993310","fields":{"slug":"/vyom","title":"Vyom"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"producer\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Producer\"), mdx(\"p\", null, \"Kafka has a binary wire protocol.This means that it is possible for applications to read messages from Kafka or write messages to Kafka simply by sending the correct byte sequences to Kafka\\u2019s network port.\"), mdx(\"p\", null, \"Key Structure is \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"ProducerRecord\")), mdx(\"p\", null), mdx(\"h1\", {\n    \"id\": \"serializer\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Serializer\"), mdx(\"p\", null, \"Converts between wire format and code\"), mdx(\"p\", null, mdx(\"a\", {\n    \"href\": \"https://https://avro.apache.org/docs/current\",\n    \"parentName\": \"p\"\n  }, \"Apache Avro\"), \"\\nDefine a common schema for serialization and deserialization\\nStore in schema Registry\\nStore schema identifier in produced message\\n\"), mdx(\"h1\", {\n    \"id\": \"creating-a-producer\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Creating a Producer\"), mdx(\"h2\", {\n    \"id\": \"in-rust\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"In [\", mdx(\"a\", {\n    \"href\": \"rust\",\n    \"title\": \"Rust\",\n    \"parentName\": \"h2\"\n  }, \"rust\"), \"]\"), mdx(\"p\", null, \"Crate : \", mdx(\"a\", {\n    \"href\": \"https://crates.io/crates/kafka\",\n    \"parentName\": \"p\"\n  }, \"kafka\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-rust\",\n    \"parentName\": \"pre\"\n  }, \"/// Producer Code\\nuse std::fmt::Write;\\nuse std::time::Duration;\\nuse kafka::producer::{Producer, Record, RequiredAcks};\\n\\nlet mut producer = Producer::from_hosts(vec!(\\\"localhost:9092\\\".to_owned()))\\n.with_ack_timeout(Duration::from_secs(1))\\n.with_required_acks(RequiredAcks::One)\\n.create()\\n.unwrap();\\n\\nlet mut buf = String::with*capacity(2);\\nfor i in 0..10 {\\nlet * = write!(&mut buf, \\\"{}\\\", i); // some computation of the message data to be sent\\nproducer.send(&Record::from_value(\\\"my-topic\\\", buf.as_bytes())).unwrap();\\nbuf.clear();\\n}\\n\")), mdx(\"p\", null, \"Crate : \", mdx(\"a\", {\n    \"href\": \"https://crates.io/crates/rdkafka\",\n    \"parentName\": \"p\"\n  }, \"rdkafka\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-Rust\",\n    \"parentName\": \"pre\"\n  }, \" sync fn produce(brokers: &str, topic_name: &str) {\\n    let producer: &FutureProducer = &ClientConfig::new()\\n        .set(\\\"bootstrap.servers\\\", brokers)\\n        .set(\\\"message.timeout.ms\\\", \\\"5000\\\")\\n        .create()\\n        .expect(\\\"Producer creation error\\\");\\n\\n    // This loop is non blocking: all messages will be sent one after the other, without waiting\\n    // for the results.\\n    let futures = (0..5)\\n        .map(|i| async move {\\n            // The send operation on the topic returns a future, which will be\\n            // completed once the result or failure from Kafka is received.\\n            let delivery_status = producer\\n                .send(\\n                    FutureRecord::to(topic_name)\\n                        .payload(&format!(\\\"Message {}\\\", i))\\n                        .key(&format!(\\\"Key {}\\\", i))\\n                        .headers(OwnedHeaders::new().add(\\\"header_key\\\", \\\"header_value\\\")),\\n                    Duration::from_secs(0),\\n                )\\n                .await;\\n\\n            // This will be executed when the result is received.\\n            info!(\\\"Delivery status for message {} received\\\", i);\\n            delivery_status\\n        })\\n        .collect::<Vec<_>>();\\n\\n    // This loop will wait until all delivery statuses have been received.\\n    for future in futures {\\n        info!(\\\"Future completed. Result: {:?}\\\", future.await);\\n    }\\n}\\n\\n\")), mdx(\"p\", null, \"Schema Registry for confluent : \", mdx(\"a\", {\n    \"href\": \"https://github.com/gklijs/schema_registry_converter\",\n    \"parentName\": \"p\"\n  }, \"https://github.com/gklijs/schema_registry_converter\")), mdx(\"p\", null, \"Confluent Write up : \", mdx(\"a\", {\n    \"href\": \"https://www.confluent.io/blog/getting-started-with-rust-and-kafka/\",\n    \"parentName\": \"p\"\n  }, \"https://www.confluent.io/blog/getting-started-with-rust-and-kafka/\")), mdx(\"hr\", null), mdx(\"h2\", {\n    \"id\": \"in-golang\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"In [\", mdx(\"a\", {\n    \"href\": \"golang\",\n    \"title\": \"Golang\",\n    \"parentName\": \"h2\"\n  }, \"golang\"), \"]\"), mdx(\"p\", null, \"Package : \", mdx(\"a\", {\n    \"href\": \"https://github.com/confluentinc/confluent-kafka-go\",\n    \"parentName\": \"p\"\n  }, \"Confluent Inc\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-golang\",\n    \"parentName\": \"pre\"\n  }, \"func main() {\\n\\n    p, err := kafka.NewProducer(&kafka.ConfigMap{\\\"bootstrap.servers\\\": \\\"localhost\\\"})\\n    if err != nil {\\n        panic(err)\\n    }\\n\\n    defer p.Close()\\n\\n    // Delivery report handler for produced messages\\n    go func() {\\n        for e := range p.Events() {\\n            switch ev := e.(type) {\\n            case *kafka.Message:\\n                if ev.TopicPartition.Error != nil {\\n                    fmt.Printf(\\\"Delivery failed: %v\\\\n\\\", ev.TopicPartition)\\n                } else {\\n                    fmt.Printf(\\\"Delivered message to %v\\\\n\\\", ev.TopicPartition)\\n                }\\n            }\\n        }\\n    }()\\n\\n    // Produce messages to topic (asynchronously)\\n    topic := \\\"myTopic\\\"\\n    for _, word := range []string{\\\"Welcome\\\", \\\"to\\\", \\\"the\\\", \\\"Confluent\\\", \\\"Kafka\\\", \\\"Golang\\\", \\\"client\\\"} {\\n        p.Produce(&kafka.Message{\\n            TopicPartition: kafka.TopicPartition{Topic: &topic, Partition: kafka.PartitionAny},\\n            Value:          []byte(word),\\n        }, nil)\\n    }\\n\\n    // Wait for message deliveries before shutting down\\n    p.Flush(15 * 1000)\\n}\\n\")), mdx(\"p\", null, \"Package : \", mdx(\"a\", {\n    \"href\": \"https://github.com/segmentio/kafka-go\",\n    \"parentName\": \"p\"\n  }, \"SegmentIO\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-golang\",\n    \"parentName\": \"pre\"\n  }, \"func producer() {\\n\\n    topic := \\\"my-topic\\\"\\n    partition := 0\\n\\n    conn, _ := kafka.DialLeader(context.Background(), \\\"tcp\\\", \\\"localhost:9092\\\", topic, partition)\\n\\n    conn.SetWriteDeadline(time.Now().Add(10*time.Second))\\n    conn.WriteMessages(\\n    kafka.Message{Value: []byte(\\\"one!\\\")},\\n    kafka.Message{Value: []byte(\\\"two!\\\")},\\n    kafka.Message{Value: []byte(\\\"three!\\\")},\\n    )\\n\\n    conn.Close()\\n}\\n\")), mdx(\"p\", null, \"Package : \", mdx(\"a\", {\n    \"href\": \"https://github.com/Shopify/sarama\",\n    \"parentName\": \"p\"\n  }, \"Sarama\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-golang\",\n    \"parentName\": \"pre\"\n  }, \"//Sync Producer\\nfunc newDataCollector(brokerList []string) sarama.SyncProducer {\\n\\n    // For the data collector, we are looking for strong consistency semantics.\\n    // Because we don't change the flush settings, sarama will try to produce messages\\n    // as fast as possible to keep latency low.\\n    config := sarama.NewConfig()\\n    config.Producer.RequiredAcks = sarama.WaitForAll // Wait for all in-sync replicas to ack the message\\n    config.Producer.Retry.Max = 10                   // Retry up to 10 times to produce the message\\n    config.Producer.Return.Successes = true\\n    tlsConfig := createTlsConfiguration()\\n    if tlsConfig != nil {\\n        config.Net.TLS.Config = tlsConfig\\n        config.Net.TLS.Enable = true\\n    }\\n\\n    // On the broker side, you may want to change the following settings to get\\n    // stronger consistency guarantees:\\n    // - For your broker, set `unclean.leader.election.enable` to false\\n    // - For the topic, you could increase `min.insync.replicas`.\\n\\n    producer, err := sarama.NewSyncProducer(brokerList, config)\\n    if err != nil {\\n        log.Fatalln(\\\"Failed to start Sarama producer:\\\", err)\\n    }\\n\\n    return producer\\n}\\n\\n// Async Producer\\nfunc newAccessLogProducer(brokerList []string) sarama.AsyncProducer {\\n\\n    // For the access log, we are looking for AP semantics, with high throughput.\\n    // By creating batches of compressed messages, we reduce network I/O at a cost of more latency.\\n    config := sarama.NewConfig()\\n    tlsConfig := createTlsConfiguration()\\n    if tlsConfig != nil {\\n        config.Net.TLS.Enable = true\\n        config.Net.TLS.Config = tlsConfig\\n    }\\n    config.Producer.RequiredAcks = sarama.WaitForLocal       // Only wait for the leader to ack\\n    config.Producer.Compression = sarama.CompressionSnappy   // Compress messages\\n    config.Producer.Flush.Frequency = 500 * time.Millisecond // Flush batches every 500ms\\n\\n    producer, err := sarama.NewAsyncProducer(brokerList, config)\\n    if err != nil {\\n        log.Fatalln(\\\"Failed to start Sarama producer:\\\", err)\\n    }\\n\\n    // We will just log to STDOUT if we're not able to produce messages.\\n    // Note: messages will only be returned here after all retry attempts are exhausted.\\n    go func() {\\n        for err := range producer.Errors() {\\n            log.Println(\\\"Failed to write access log entry:\\\", err)\\n        }\\n    }()\\n\\n    return producer\\n}\\n\\ngo func sendMessage(){\\n        // Synch\\n        partition, offset, err := s.DataCollector.SendMessage(&sarama.ProducerMessage{\\n            Topic: \\\"important\\\",\\n            Value: sarama.StringEncoder(r.URL.RawQuery),\\n        })\\n        // Async\\n        s.AccessLogProducer.Input() <- &sarama.ProducerMessage{\\n            Topic: \\\"access_log\\\",\\n            Key:   sarama.StringEncoder(r.RemoteAddr),\\n            Value: entry,\\n        }\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"67abd20c-6607-580b-bb55-74eeb8467444","fields":{"slug":"/producer","title":"Producer"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"consumer\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Consumer\"), mdx(\"ul\", null, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Subscribes to topics and receives message\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Consumer Group -> method of scaling consumption\"), mdx(\"ul\", {\n    \"parentName\": \"li\"\n  }, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Membership triggered by a \", mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"JoinGroup\"), \" call\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"First member is the de-facto group leader\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"leader assigns partitions to consumers in the consumer group\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Membership is maintained by sending \", mdx(\"em\", {\n    \"parentName\": \"li\"\n  }, \"heartbeats\"), \" at intervals regularly to the \", mdx(\"em\", {\n    \"parentName\": \"li\"\n  }, \"group coordinator\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Sent during \", mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"poll\"), \" and \", mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"commit\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"missing heartbeats for a period will trigger rebalance as the consumer is thought to be dead\"))), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, mdx(\"em\", {\n    \"parentName\": \"p\"\n  }, \"Rebalance\"), \" moving partition ownership from one consumer to another\"), mdx(\"ul\", {\n    \"parentName\": \"li\"\n  }, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"high scalability and availability\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"creates a short unavailability window\")))), mdx(\"p\", null), mdx(\"h1\", {\n    \"id\": \"creating-a-consumer\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Creating a Consumer\"), mdx(\"h2\", {\n    \"id\": \"in-rust\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"In [\", mdx(\"a\", {\n    \"href\": \"rust\",\n    \"title\": \"Rust\",\n    \"parentName\": \"h2\"\n  }, \"rust\"), \"]\"), mdx(\"p\", null, \"Crate : \", mdx(\"a\", {\n    \"href\": \"https://crates.io/crates/kafka\",\n    \"parentName\": \"p\"\n  }, \"kafka\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-Rust\",\n    \"parentName\": \"pre\"\n  }, \"use kafka::consumer::{Consumer, FetchOffset, GroupOffsetStorage};\\nlet mut consumer =\\n   Consumer::from_hosts(vec!(\\\"localhost:9092\\\".to_owned()))\\n      .with_topic_partitions(\\\"my-topic\\\".to_owned(), &[0, 1])\\n      .with_fallback_offset(FetchOffset::Earliest)\\n      .with_group(\\\"my-group\\\".to_owned())\\n      .with_offset_storage(GroupOffsetStorage::Kafka)\\n      .create()\\n      .unwrap();\\nloop {\\n  for ms in consumer.poll().unwrap().iter() {\\n    for m in ms.messages() {\\n      println!(\\\"{:?}\\\", m);\\n    }\\n    consumer.consume_messageset(ms);\\n  }\\n  consumer.commit_consumed().unwrap();\\n}\\n\")), mdx(\"p\", null, \"Crate : \", mdx(\"a\", {\n    \"href\": \"https://crates.io/crates/rdkafka\",\n    \"parentName\": \"p\"\n  }, \"rdkafka\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-Rust\",\n    \"parentName\": \"pre\"\n  }, \"async fn consume(brokers: &str, group_id: &str, topics: &[&str]) {\\n    let context = CustomContext;\\n\\n    let consumer: LoggingConsumer = ClientConfig::new()\\n        .set(\\\"group.id\\\", group_id)\\n        .set(\\\"bootstrap.servers\\\", brokers)\\n        .set(\\\"enable.partition.eof\\\", \\\"false\\\")\\n        .set(\\\"session.timeout.ms\\\", \\\"6000\\\")\\n        .set(\\\"enable.auto.commit\\\", \\\"true\\\")\\n        //.set(\\\"statistics.interval.ms\\\", \\\"30000\\\")\\n        //.set(\\\"auto.offset.reset\\\", \\\"smallest\\\")\\n        .set_log_level(RDKafkaLogLevel::Debug)\\n        .create_with_context(context)\\n        .expect(\\\"Consumer creation failed\\\");\\n\\n    consumer\\n        .subscribe(&topics.to_vec())\\n        .expect(\\\"Can't subscribe to specified topics\\\");\\n\\n    // consumer.start() returns a stream. The stream can be used ot chain together expensive steps,\\n    // such as complex computations on a thread pool or asynchronous IO.\\n    let mut message_stream = consumer.start();\\n\\n    while let Some(message) = message_stream.next().await {\\n        match message {\\n            Err(e) => warn!(\\\"Kafka error: {}\\\", e),\\n            Ok(m) => {\\n                let payload = match m.payload_view::<str>() {\\n                    None => \\\"\\\",\\n                    Some(Ok(s)) => s,\\n                    Some(Err(e)) => {\\n                        warn!(\\\"Error while deserializing message payload: {:?}\\\", e);\\n                        \\\"\\\"\\n                    }\\n                };\\n                info!(\\\"key: '{:?}', payload: '{}', topic: {}, partition: {}, offset: {}, timestamp: {:?}\\\",\\n                      m.key(), payload, m.topic(), m.partition(), m.offset(), m.timestamp());\\n                if let Some(headers) = m.headers() {\\n                    for i in 0..headers.count() {\\n                        let header = headers.get(i).unwrap();\\n                        info!(\\\"  Header {:#?}: {:?}\\\", header.0, header.1);\\n                    }\\n                }\\n                consumer.commit_message(&m, CommitMode::Async).unwrap();\\n            }\\n        };\\n    }\\n}\\n\")), mdx(\"hr\", null), mdx(\"h2\", {\n    \"id\": \"in-golang\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"In [\", mdx(\"a\", {\n    \"href\": \"golang\",\n    \"title\": \"Golang\",\n    \"parentName\": \"h2\"\n  }, \"golang\"), \"]\"), mdx(\"p\", null, \"Package : \", mdx(\"a\", {\n    \"href\": \"https://github.com/confluentinc/confluent-kafka-go\",\n    \"parentName\": \"p\"\n  }, \"Confluent Inc\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-golang\",\n    \"parentName\": \"pre\"\n  }, \"func main() {\\n\\n    c, err := kafka.NewConsumer(&kafka.ConfigMap{\\n        \\\"bootstrap.servers\\\": \\\"localhost\\\",\\n        \\\"group.id\\\":          \\\"myGroup\\\",\\n        \\\"auto.offset.reset\\\": \\\"earliest\\\",\\n    })\\n\\n    if err != nil {\\n        panic(err)\\n    }\\n\\n    c.SubscribeTopics([]string{\\\"myTopic\\\", \\\"^aRegex.*[Tt]opic\\\"}, nil)\\n\\n    for {\\n        msg, err := c.ReadMessage(-1)\\n        if err == nil {\\n            fmt.Printf(\\\"Message on %s: %s\\\\n\\\", msg.TopicPartition, string(msg.Value))\\n        } else {\\n            // The client will automatically try to recover from all errors.\\n            fmt.Printf(\\\"Consumer error: %v (%v)\\\\n\\\", err, msg)\\n        }\\n    }\\n\\n    c.Close()\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"package--segmentio\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Package : \", mdx(\"a\", {\n    \"href\": \"https://github.com/segmentio/kafka-go\",\n    \"parentName\": \"h2\"\n  }, \"SegmentIO\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-golang\",\n    \"parentName\": \"pre\"\n  }, \"func consumer(){}\\nr := kafka.NewReader(kafka.ReaderConfig{\\n    Brokers:   []string{\\\"localhost:9092\\\"},\\n    Topic:     \\\"topic-A\\\",\\n    Partition: 0,\\n    MinBytes:  10e3, // 10KB\\n    MaxBytes:  10e6, // 10MB\\n})\\nr.SetOffset(42)\\n\\nfor {\\n    m, err := r.ReadMessage(context.Background())\\n    if err != nil {\\n        break\\n    }\\n    fmt.Printf(\\\"message at offset %d: %s = %s\\\\n\\\", m.Offset, string(m.Key), string(m.Value))\\n}\\n\\nr.Close()\\n}\\n\")), mdx(\"p\", null, \"Package : \", mdx(\"a\", {\n    \"href\": \"https://github.com/Shopify/sarama\",\n    \"parentName\": \"p\"\n  }, \"Sarama\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-golang\",\n    \"parentName\": \"pre\"\n  }, \"// ConsumeClaim must start a consumer loop of ConsumerGroupClaim's Messages().\\nfunc (consumer *Consumer) ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {\\n\\n    // NOTE:\\n    // Do not move the code below to a goroutine.\\n    // The `ConsumeClaim` itself is called within a goroutine, see:\\n    // https://github.com/Shopify/sarama/blob/master/consumer_group.go#L27-L29\\n    for message := range claim.Messages() {\\n        log.Printf(\\\"Message claimed: value = %s, timestamp = %v, topic = %s\\\", string(message.Value), message.Timestamp, message.Topic)\\n        session.MarkMessage(message, \\\"\\\")\\n    }\\n\\n    return nil\\n}\\n\\ngo func() comsumer{\\n        defer wg.Done()\\n        for {\\n            // `Consume` should be called inside an infinite loop, when a\\n            // server-side rebalance happens, the consumer session will need to be\\n            // recreated to get the new claims\\n            if err := client.Consume(ctx, strings.Split(topics, \\\",\\\"), &consumer); err != nil {\\n                log.Panicf(\\\"Error from consumer: %v\\\", err)\\n            }\\n            // check if context was cancelled, signaling that the consumer should stop\\n            if ctx.Err() != nil {\\n                return\\n            }\\n            consumer.ready = make(chan bool)\\n        }\\n    }()\\n\\n\")), mdx(\"h1\", {\n    \"id\": \"commits\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Commits\"), mdx(\"ul\", null, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Consumers use kafka to track their position in each partition\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"commit\"), \" act of updating current position in kafka\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"message \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"__consumer_offsets\"), \" topic with the offset for each partition\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"when rebalance each consumer receives a new partition and obtains the latest committed offset from where to start reading\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Commit Strategy\"), mdx(\"ul\", {\n    \"parentName\": \"li\"\n  }, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Automatic\"), mdx(\"ul\", {\n    \"parentName\": \"li\"\n  }, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Done by consumer every 5 seconds configurable\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Commits largest offset from \", mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"poll\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"call to \", mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"poll\"), \" will always commit the last offset\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"results in double processing if \", mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"rebalance\"), \" occurs in between a 5 sec window\"))), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Commit Current Offset\"), mdx(\"ul\", {\n    \"parentName\": \"li\"\n  }, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Gives control to the developer\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"commitSync\"), \" triggers commit of the last offset returned by \", mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"poll\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"must be called after processing all messages\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Synchronous call blocks the application\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Auto retry till success of non retry-able failure\"))), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Asynchronous Commit\"), mdx(\"ul\", {\n    \"parentName\": \"li\"\n  }, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Fire and forget till we get a callback\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Does not auto retry as a later commit request might have latest Offset\"))), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Async + Sync Commit\"), mdx(\"ul\", {\n    \"parentName\": \"li\"\n  }, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"CommitAsync\"), \" always\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Trigger a CommitSync just before exit\")))))));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"a9f33b82-4aa7-599b-a242-54db28ac76f1","fields":{"slug":"/consumer","title":"Consumer"}}}],"inboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"vyom\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Vyom\"), mdx(\"p\", null, \"This bot is in [\", mdx(\"a\", {\n    \"href\": \"rust\",\n    \"title\": \"Rust\",\n    \"parentName\": \"p\"\n  }, \"rust\"), \"]\"), mdx(\"p\", null, \"Recently while browsing \", mdx(\"a\", {\n    \"href\": \"https://old.reddit.com\",\n    \"parentName\": \"p\"\n  }, \"reddit\"), \" I came up on a \", mdx(\"a\", {\n    \"href\": \"https://www.reddit.com/r/rust/comments/i1satq/webference_rusty_days_2020_all_recorded_talks/g01rwq8/?context=3\",\n    \"parentName\": \"p\"\n  }, \"post\"), \" in the \", mdx(\"a\", {\n    \"href\": \"https://old.reddit.com\",\n    \"parentName\": \"p\"\n  }, \"/r/rust\"), \" subreddit which was a link to a youtube playlist for the Rust-Wroclaw conference/meetup, however there was no way I could find the contents of the playlist without going to Youtube. This was a nuance so I went to Youtube and curated the list.\"), mdx(\"p\", null, mdx(\"img\", {\n    \"src\": \"https://dev-to-uploads.s3.amazonaws.com/i/fxof8cdxfizue63qkz7d.png\",\n    \"alt\": \"Manually listing the entries\",\n    \"parentName\": \"p\"\n  })), mdx(\"p\", null, \"This was going to be tiresome if I'd have to do it every time I see a link that is a YouTube playlist. So here we are writing a bot do this task for everyone. This bot will run on a server somewhere (hopefully forever) and curate playlist info for all the people who avail its service.\"), mdx(\"h1\", {\n    \"id\": \"creating-credentials-for-our-bot\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Creating Credentials For Our Bot\"), mdx(\"p\", null, \"In order to write our bot we first need to get some credentials from reddit so that we can access the \", mdx(\"a\", {\n    \"href\": \"https://old.reddit.com/dev/api\",\n    \"parentName\": \"p\"\n  }, \"reddit apis\"), \" programmatically.\"), mdx(\"p\", null, \"First you need an application id and secret so reddit knows your application. We can get this information by going to \", mdx(\"a\", {\n    \"href\": \"https://www.reddit.com/prefs/apps\",\n    \"parentName\": \"p\"\n  }, \"preferences/app\"), \" and clicking \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"are you a developer? create an app...\"), \" button\"), mdx(\"p\", null, \"Reddit lets us choose the type of the app we want to build. The three types of app are :\"), mdx(\"ul\", null, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Web app: Runs as part of a web service on a server you control. Can keep a secret.\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Installed app: Runs on devices you don't control, such as the user's mobile phone. Cannot keep a secret, and therefore, does not receive one.\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Script app: Runs on hardware you control, such as your own laptop or server. Can keep a secret. Only has access to your account.\"))), mdx(\"p\", null, \"More info about about the apps can be found \", mdx(\"a\", {\n    \"href\": \"https://github.com/reddit-archive/reddit/wiki/oauth2-app-types\",\n    \"parentName\": \"p\"\n  }, \"here\"), \".\"), mdx(\"p\", null, \"We choose the \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"script\"), \" type, enter a name and description for our bot, and use  the dummy url \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"http://www.example.com/unused/redirect/uri\"), \" for the redirect url.\"), mdx(\"p\", null, mdx(\"img\", {\n    \"src\": \"https://dev-to-uploads.s3.amazonaws.com/i/weyxca7xkhcnfrwo36kj.png\",\n    \"alt\": \"Create App\",\n    \"parentName\": \"p\"\n  })), mdx(\"p\", null, \"We have now created the credentials with Client Id : \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"TjC0s2uTaTHYCg\"), \" and Client Secret : \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"mrkAaWitnXLf_DiRagIRS_33cD8\"), \".\"), mdx(\"p\", null, mdx(\"img\", {\n    \"src\": \"https://dev-to-uploads.s3.amazonaws.com/i/xj0q1m7li5abg060ari6.png\",\n    \"alt\": \"Credentials\",\n    \"parentName\": \"p\"\n  })), mdx(\"h1\", {\n    \"id\": \"using-and-storing-the-credentials\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Using and Storing the credentials\"), mdx(\"p\", null, \"We can now use the credentials in our source code and use it in our code.\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-rust\",\n    \"parentName\": \"pre\"\n  }, \"# main.rs\\n\\nstatic  CLIENT_ID:&str=\\\"TjC0s2uTaTHYCg\\\";\\nstatic  CLIENT_SECRET:&str=\\\"mrkAaWitnXLf_DiRagIRS_33cD8\\\";\\n\\nfn main(){\\n    println!(\\\"Client ID: {}\\\",CLIENT_ID);\\n    println!(\\\"Client Secret: {}\\\",CLIENT_SECRET);\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-shell\",\n    \"parentName\": \"pre\"\n  }, \"DeltaManiac @ ~/git/rust/vyom\\n\\u2514\\u2500 $ cargo run\\n    Finished dev [unoptimized + debuginfo] target(s) in 0.08s\\n     Running `target/debug/vyom`\\nClient ID: SmQ7CzGkKA62yA\\nClient Secret: UItY35BYBEN_rFVnGVzud9Pig6g\\n\")), mdx(\"p\", null, \"This is a very easy and clear way to handle credentials but its flawed in two ways.\"), mdx(\"ul\", null, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"If we need to change the credentials then we would have to change the code, rebuild the app and redeploy the app.\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"If we decide to share the code with someone or push it github, it will expose our credentials, which can be used to hijack our account and do bad things.\"))), mdx(\"p\", null, \"So lets see if we can fix the first problem, by moving the credentials out of the source code. But where do we put it then ? If you're thinking about environment variables then youre absolutely right. Environment variables are a good place to store such values and they are fairly easy to change.\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-rust\",\n    \"parentName\": \"pre\"\n  }, \"# main.rs\\n\\nfn main(){\\n    match std::env::var(\\\"CLIENT_ID1\\\") {\\n        Ok(client_id) => println!(\\\"Client ID: {}\\\", client_id),\\n        Err(e) => panic!(\\\"Couldn't read CLIENT_ID ({})\\\", e),\\n    };\\n    match std::env::var(\\\"CLIENT_SECRET1\\\") {\\n        Ok(client_secret) => println!(\\\"Client Secret: {}\\\", client_secret),\\n        Err(e) => panic!(\\\"Couldn't read CLIENT_SECRET ({})\\\", e),\\n    };\\n}\\n\")), mdx(\"p\", null, \"Since our bot wont work without a \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"client_id\"), \" and a \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"client_secret\"), \" we call \", mdx(\"a\", {\n    \"href\": \"https://doc.rust-lang.org/stable/std/macro.panic.html\",\n    \"parentName\": \"p\"\n  }, \"panic!\"), \" so that the application exits with an error.\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-shell\",\n    \"parentName\": \"pre\"\n  }, \"(base) DeltaManiac @ ~/git/rust/vyom\\n\\u2514\\u2500 $ cargo run\\n    Finished dev [unoptimized + debuginfo] target(s) in 0.41s\\n     Running `target/debug/vyom`\\nthread 'main' panicked at \\\\'Couldn\\\\'t read CLIENT_ID (environment variable not found), \\nsrc/main.rs:9:19\\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\\n\\n# Set the environment variables\\n(base) DeltaManiac @ ~/git/rust/vyom\\n\\u2514\\u2500 $ export CLIENT_SECRET=UItY35BYBEN_rFVnGVzud9Pig6g\\n(base) DeltaManiac @ ~/git/rust/vyom\\n\\u2514\\u2500 $ export CLIENT_ID=SmQ7CzGkKA62yA\\n\\n(base) DeltaManiac @ ~/git/rust/vyom\\n\\u2514\\u2500 $ cargo run\\n    Finished dev [unoptimized + debuginfo] target(s) in 0.47s\\n     Running `target/debug/vyom`\\nClient ID: SmQ7CzGkKA62yA\\nClient Secret: UItY35BYBEN_rFVnGVzud9Pig6g\\n\")), mdx(\"p\", null, \"Most of the time we don't really want to export a lot of environment variables manually. Its exhausting. We could fix this problem by writing a shell script that has all our \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"export\"), \" statement... or we can use \", mdx(\"a\", {\n    \"href\": \"https://crates.io/crates/dotenv\",\n    \"parentName\": \"p\"\n  }, \"dotenv\"), \". Dotenv is a way to put environment variables in a \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \".env\"), \" file and read them. Dotenv is smart to enough to only read from the file if the Environment Variable is not set on the system.\"), mdx(\"p\", null, \"We first add the \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"dotenv\"), \" dependency to our \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"Cargo.toml\"), \" file.\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-toml\",\n    \"parentName\": \"pre\"\n  }, \"# Cargo.toml\\n[package]\\nname = \\\"vyom\\\"\\nversion = \\\"0.1.0\\\"\\nauthors = [\\\"DeltaManiac <maxpaynered@gmail.com>\\\"]\\nedition = \\\"2018\\\"\\n\\n[dependencies]\\ndotenv_codegen=\\\"0.15.0\\\" # dotenv dependency\\n\")), mdx(\"p\", null, \"We then setup the environment variables in the \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \".env\"), \" file.\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-shell\",\n    \"parentName\": \"pre\"\n  }, \"# .env\\nCLIENT_ID=test_123\\nCLIENT_SECRET=test_321\\nTest=DisTest\\n\")), mdx(\"p\", null, \"We finally modify our code to use the \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"dotenv\"), \" crate.\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-rust\",\n    \"parentName\": \"pre\"\n  }, \"# main.rs\\n\\n#[macro_use]\\nextern crate dotenv_codegen;\\n\\nfn main(){\\n    println!(\\\"Env Not on Sys: {}\\\",dotenv!(\\\"Test\\\"));\\n    println!(\\\"Client ID: {}\\\",dotenv!(\\\"CLIENT_ID\\\"));\\n    println!(\\\"Client Secret: {}\\\",dotenv!(\\\"CLIENT_SECRET\\\"));\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-shell\",\n    \"parentName\": \"pre\"\n  }, \"(base) DeltaManiac @ ~/git/rust/vyom\\n\\u2514\\u2500 $ cargo run\\n    Finished dev [unoptimized + debuginfo] target(s) in 0.08s\\n     Running `target/debug/vyom`\\nEnv Not on Sys: ss #Value from the .env file\\nClient ID: SmQ7CzGkKA62yA #Value from the system\\nClient Secret: UItY35BYBEN_rFVnGVzud9Pig6g #Value from the system\\n\")), mdx(\"h1\", {\n    \"id\": \"how-will-the-bot-work-\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"How will the bot work ?\"), mdx(\"p\", null, \"The bot will listen to a mention like \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"/u/VyomBot\"), \" and would check if the post is a link to a youtube playlist or the parent comment of the mention is a YouTube playlist.\"), mdx(\"h1\", {\n    \"id\": \"setting-up-reddit\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Setting up Reddit\"), mdx(\"p\", null, \"I've followed the following steps to setup reddit for testing/developing this bot\"), mdx(\"ol\", null, mdx(\"li\", {\n    \"parentName\": \"ol\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Created a new user called \", mdx(\"a\", {\n    \"href\": \"https://old.reddit.com/user/VyomBot\",\n    \"parentName\": \"p\"\n  }, \"VyomBot\"), \" so that the bot can be mentioned via \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"/u/VyomBot\"))), mdx(\"li\", {\n    \"parentName\": \"ol\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Registered a new app of \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"script\"), \" type for \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"/u/VyomBot\"))), mdx(\"li\", {\n    \"parentName\": \"ol\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Create a new \", mdx(\"a\", {\n    \"href\": \"https://old.reddit.com/ur/VyomBot\",\n    \"parentName\": \"p\"\n  }, \"subreddit\"), \" \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"/r/VyomBot\"), \" as a test play ground.\"))), mdx(\"p\", null, mdx(\"img\", {\n    \"src\": \"https://dev-to-uploads.s3.amazonaws.com/i/vgu4s3kk5s6bxvdrhdrh.png\",\n    \"alt\": \"/r/VyomBot\",\n    \"parentName\": \"p\"\n  })), mdx(\"ol\", {\n    \"start\": 4\n  }, mdx(\"li\", {\n    \"parentName\": \"ol\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Create a new \", mdx(\"a\", {\n    \"href\": \"https://www.reddit.com/r/VyomBot/comments/i6fk15/test_playlist/?\",\n    \"parentName\": \"p\"\n  }, \"post\"), \" with the link to the playlist.\")), mdx(\"li\", {\n    \"parentName\": \"ol\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Mention \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"/u/VyomBot\"), \" in the comments.\\n\", mdx(\"img\", {\n    \"src\": \"https://dev-to-uploads.s3.amazonaws.com/i/vriyg18m5dgc5k8rklc4.png\",\n    \"alt\": \"Alt Text\",\n    \"parentName\": \"p\"\n  })))), mdx(\"h1\", {\n    \"id\": \"talking-to-reddit\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Talking to Reddit\"), mdx(\"h2\", {\n    \"id\": \"getting-messages-from-inbox\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Getting Messages from Inbox\"), mdx(\"p\", null, \"Lets start off by querying reddit to see if we have a new mention and printing the message. We will use the \", mdx(\"a\", {\n    \"href\": \"https://crates.io/crates/roux\",\n    \"parentName\": \"p\"\n  }, \"roux\"), \" crate for interacting with the reddit apis.\\nDirect quote from the description of the crate\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    \"parentName\": \"blockquote\"\n  }, \"A simple, asynchronous Reddit API wrapper implemented in Rust.\\nThis means that we have to use a framework like \", mdx(\"a\", {\n    \"href\": \"https://crates.io/crates/tokio\",\n    \"parentName\": \"p\"\n  }, \"tokio\"), \" to provide the async runtime for our bot.\\nLets go about doing that.\")), mdx(\"p\", null, \"Add the dependencies to our Cargo.toml file.\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-toml\",\n    \"parentName\": \"pre\"\n  }, \"# Cargo.toml\\n[package]\\nname = \\\"vyom\\\"\\nversion = \\\"0.1.0\\\"\\nauthors = [\\\"DeltaManiac <maxpaynered@gmail.com>\\\"]\\nedition = \\\"2018\\\"\\n\\n[dependencies]\\ndotenv_codegen=\\\"0.15.0\\\" # dotenv dependency\\nroux=\\\"1.0.0\\\" # roux dependency\\ntokio = {version=\\\"0.2.22\\\",features=[\\\"macros\\\"]} # tokio dependency and only enable the macro feature\\n\")), mdx(\"p\", null, \"Update our code to use the library and call the reddit apis.\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-rust\",\n    \"parentName\": \"pre\"\n  }, \"# main.rs\\n\\n#[macro_use]\\nextern crate dotenv_codegen;\\n#[macro_use]\\nextern crate log; // Used for logging\\nuse roux::Reddit;\\n\\n#[tokio::main]\\nasync fn main() {\\n    match Reddit::new(\\n        dotenv!(\\\"VYOM_USERAGENT\\\"),\\n        dotenv!(\\\"VYOM_CLIENT_ID\\\"),\\n        dotenv!(\\\"VYOM_CLIENT_SECRET\\\"),\\n    )\\n    .username(dotenv!(\\\"VYOM_USERNAME\\\"))\\n    .password(dotenv!(\\\"VYOM_PASSWORD\\\"))\\n    .login()\\n    .await\\n    {   // Try to make a new client with the credentials\\n        Ok(client) => match client.inbox().await {\\n            // Fetch the inbox of the logged in user\\n            Ok(listing) => {\\n                println!(\\\"Message Count {}\\\", listing.data.children.len());\\n                dbg!(listing.data.children.get(0).unwrap());\\n            }\\n            Err(_) => {\\n                error!(\\\"Failed to fetch messages\\\");\\n            }\\n        },\\n        Err(e) => panic!(e),\\n    }\\n}\\n\\n\")), mdx(\"p\", null, \"When we run the program we get the number of messages we have and the \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"dbg!\"), \" macro shows what the passed in variable which in this case is a \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"InboxItem\"), \" struct, looks like.\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-shell\",\n    \"parentName\": \"pre\"\n  }, \"(base) DeltaManiac @ ~/git/rust/vyom\\n\\u2514\\u2500 $ cargo run\\n    Finished dev [unoptimized + debuginfo] target(s) in 3.71s\\n     Running `target/debug/vyom`\\nMessage Count 5\\n[src/main.rs:24] &listing.data.children.get(0).unwrap().data = InboxItem {\\n    id: \\\"g0vfbra\\\",\\n    subject: \\\"username mention\\\",\\n    was_comment: true,\\n    author: Some(\\n        \\\"DeltaManiac\\\",\\n    ),\\n    parent_id: Some(\\n        \\\"t3_i6fk15\\\",\\n    ),\\n    subreddit_name_prefixed: Some(\\n        \\\"r/VyomBot\\\",\\n    ),\\n    new: true, \\n    type: \\\"username_mention\\\",\\n    body: \\\"/u/VyomBot\\\",\\n    dest: \\\"VyomBot\\\",\\n    body_html: \\\"&lt;!-- SC_OFF --&gt;&lt;div class=\\\\\\\"md\\\\\\\"&gt;&lt;p&gt;&lt;a href=\\\\\\\"/u/VyomBot\\\\\\\"&gt;/u/VyomBot&lt;/a&gt;&lt;/p&gt;\\\\n&lt;/div&gt;&lt;!-- SC_ON --&gt;\\\",\\n    name: \\\"t1_g0vfbra\\\",\\n    created: 1596987973.0,\\n    created_utc: 1596959173.0,\\n    context: \\\"/r/VyomBot/comments/i6fk15/test_playlist/g0vfbra/?context=3\\\",\\n}\\n\")), mdx(\"p\", null, \"We can use the \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"new\"), \" property to identify if this is a message that we had previously read.\\nThe type property can be used to determine if the item is a comment or a username mention.\\nWe can use this to iterate over the messages retrieved and  and determine the messages that we have to reply to.\"), mdx(\"h1\", {\n    \"id\": \"replying-to-the-message\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Replying to the message\"), mdx(\"p\", null, \"Roux provides us a convenient method aptly name \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"comment\"), \" to reply to the message. Let's go ahead and use this to reply to the message.\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-rust\",\n    \"parentName\": \"pre\"\n  }, \"# main.rs\\n\\nasync fn main() {\\n...\\n...\\n// Fetch the inbox of the logged in user\\n    Ok(listing) => {\\n        for message in listing.data.children.iter() {\\n            is message unread and of type \\\"username_mention\\\"\\n            if message.data.new && message.data.r#type == \\\"username_mention\\\" {\\n                match client\\n                    .comment(\\n                        \\\"You have been Noted by Vyom. Please Stand By!\\\",\\n                        &message.data.name.as_str(),\\n                    )\\n                    .await\\n                {\\n                    Ok(_) => info!(\\\"Replied to {}\\\", message.data.name),\\n                    Err(_) => error!(\\\"Failed to reply to mention\\\"),\\n                };\\n            }\\n        }\\n    }\\n...\\n...\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    \"parentName\": \"blockquote\"\n  }, \"Psst.., I'll let you in on something cool. In rust \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"type\"), \" is a reserved keyword. In most programming languages you can use a keyword only as keyword, e.g. you \", mdx(\"em\", {\n    \"parentName\": \"p\"\n  }, \"cannot\"), \" have a variable called \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"for\"), \". In rust we can use \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"type\"), \" as an attribute of a struct and access it by specifing it as a raw string using the \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"r#\"), \" like \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"message.data.r#type\"))), mdx(\"p\", null, \"Now that we have written the code lets run it and see what happens..\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-shell\",\n    \"parentName\": \"pre\"\n  }, \"(base) DeltaManiac @ ~/git/rust/vyom\\n\\u2514\\u2500 $ cargo run\\n    Finished dev [unoptimized + debuginfo] target(s) in 4.45s\\n     Running `target/debug/vyom`\\n\")), mdx(\"p\", null, \"Nice! It logged that we replied to the mention. Lets run it again, this time it should not reply to an allready replied message as we have read it.\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-shell\",\n    \"parentName\": \"pre\"\n  }, \"[2020-08-09T12:59:25Z INFO  vyom] Replied to t1_g0vfbra\\n(base) DeltaManiac @ ~/git/rust/vyom\\n\\u2514\\u2500 $ cargo run\\n    Finished dev [unoptimized + debuginfo] target(s) in 0.10s\\n     Running `target/debug/vyom`\\n[2020-08-09T12:59:29Z INFO  vyom] Replied to t1_g0vfbra\\n(base) DeltaManiac @ ~/git/rust/vyom\\n\\u2514\\u2500 $ cargo run\\n    Finished dev [unoptimized + debuginfo] target(s) in 0.09s\\n     Running `target/debug/vyom`\\n[2020-08-09T12:59:32Z INFO  vyom] Replied to t1_g0vfbra\\n\")), mdx(\"p\", null, \"Damn! IT REPLIED AGAIN!!! And this is what the subbreddit looks like.\"), mdx(\"p\", null, mdx(\"img\", {\n    \"src\": \"https://dev-to-uploads.s3.amazonaws.com/i/fdjrhs96s7yujerdqbu8.png\",\n    \"alt\": \"replies,Replies,REPLIES\",\n    \"parentName\": \"p\"\n  })), mdx(\"p\", null, \"I guess this a good place to stop.\\nIn the next part we will find the reason for this pesky little bug and squash it.\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"797a5aeb-060e-5315-b65f-4fe1a1993310","fields":{"slug":"/vyom","title":"Vyom"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"foam-bubbles\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Foam Bubbles\"), mdx(\"p\", null, \"[\", mdx(\"a\", {\n    \"href\": \"inbox\",\n    \"title\": \"Inbox\",\n    \"parentName\": \"p\"\n  }, \"inbox\"), \"]\"), mdx(\"p\", null, \"[\", mdx(\"a\", {\n    \"href\": \"todo\",\n    \"title\": \"Todo / Reading List\",\n    \"parentName\": \"p\"\n  }, \"todo\"), \"]\"), mdx(\"p\", null, \"[\", mdx(\"a\", {\n    \"href\": \"dwarf\",\n    \"title\": \"Dwarf Debugging Format\",\n    \"parentName\": \"p\"\n  }, \"dwarf\"), \"]\"), mdx(\"p\", null, \"[\", mdx(\"a\", {\n    \"href\": \"kafka\",\n    \"title\": \"Apache Kafka\",\n    \"parentName\": \"p\"\n  }, \"kafka\"), \"]\"), mdx(\"p\", null, \"[\", mdx(\"a\", {\n    \"href\": \"elf\",\n    \"title\": \"elf\",\n    \"parentName\": \"p\"\n  }, \"elf\"), \"]\"), mdx(\"p\", null, \"[\", mdx(\"a\", {\n    \"href\": \"rust\",\n    \"title\": \"Rust\",\n    \"parentName\": \"p\"\n  }, \"rust\"), \"]\"), mdx(\"p\", null, \"[\", mdx(\"a\", {\n    \"href\": \"golang\",\n    \"title\": \"Golang\",\n    \"parentName\": \"p\"\n  }, \"golang\"), \"]\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"0b774b8d-a51d-55d2-8d2d-8f7d194fe0d5","fields":{"slug":"/readme","title":"Foam Bubbles"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"producer\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Producer\"), mdx(\"p\", null, \"Kafka has a binary wire protocol.This means that it is possible for applications to read messages from Kafka or write messages to Kafka simply by sending the correct byte sequences to Kafka\\u2019s network port.\"), mdx(\"p\", null, \"Key Structure is \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"ProducerRecord\")), mdx(\"p\", null), mdx(\"h1\", {\n    \"id\": \"serializer\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Serializer\"), mdx(\"p\", null, \"Converts between wire format and code\"), mdx(\"p\", null, mdx(\"a\", {\n    \"href\": \"https://https://avro.apache.org/docs/current\",\n    \"parentName\": \"p\"\n  }, \"Apache Avro\"), \"\\nDefine a common schema for serialization and deserialization\\nStore in schema Registry\\nStore schema identifier in produced message\\n\"), mdx(\"h1\", {\n    \"id\": \"creating-a-producer\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Creating a Producer\"), mdx(\"h2\", {\n    \"id\": \"in-rust\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"In [\", mdx(\"a\", {\n    \"href\": \"rust\",\n    \"title\": \"Rust\",\n    \"parentName\": \"h2\"\n  }, \"rust\"), \"]\"), mdx(\"p\", null, \"Crate : \", mdx(\"a\", {\n    \"href\": \"https://crates.io/crates/kafka\",\n    \"parentName\": \"p\"\n  }, \"kafka\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-rust\",\n    \"parentName\": \"pre\"\n  }, \"/// Producer Code\\nuse std::fmt::Write;\\nuse std::time::Duration;\\nuse kafka::producer::{Producer, Record, RequiredAcks};\\n\\nlet mut producer = Producer::from_hosts(vec!(\\\"localhost:9092\\\".to_owned()))\\n.with_ack_timeout(Duration::from_secs(1))\\n.with_required_acks(RequiredAcks::One)\\n.create()\\n.unwrap();\\n\\nlet mut buf = String::with*capacity(2);\\nfor i in 0..10 {\\nlet * = write!(&mut buf, \\\"{}\\\", i); // some computation of the message data to be sent\\nproducer.send(&Record::from_value(\\\"my-topic\\\", buf.as_bytes())).unwrap();\\nbuf.clear();\\n}\\n\")), mdx(\"p\", null, \"Crate : \", mdx(\"a\", {\n    \"href\": \"https://crates.io/crates/rdkafka\",\n    \"parentName\": \"p\"\n  }, \"rdkafka\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-Rust\",\n    \"parentName\": \"pre\"\n  }, \" sync fn produce(brokers: &str, topic_name: &str) {\\n    let producer: &FutureProducer = &ClientConfig::new()\\n        .set(\\\"bootstrap.servers\\\", brokers)\\n        .set(\\\"message.timeout.ms\\\", \\\"5000\\\")\\n        .create()\\n        .expect(\\\"Producer creation error\\\");\\n\\n    // This loop is non blocking: all messages will be sent one after the other, without waiting\\n    // for the results.\\n    let futures = (0..5)\\n        .map(|i| async move {\\n            // The send operation on the topic returns a future, which will be\\n            // completed once the result or failure from Kafka is received.\\n            let delivery_status = producer\\n                .send(\\n                    FutureRecord::to(topic_name)\\n                        .payload(&format!(\\\"Message {}\\\", i))\\n                        .key(&format!(\\\"Key {}\\\", i))\\n                        .headers(OwnedHeaders::new().add(\\\"header_key\\\", \\\"header_value\\\")),\\n                    Duration::from_secs(0),\\n                )\\n                .await;\\n\\n            // This will be executed when the result is received.\\n            info!(\\\"Delivery status for message {} received\\\", i);\\n            delivery_status\\n        })\\n        .collect::<Vec<_>>();\\n\\n    // This loop will wait until all delivery statuses have been received.\\n    for future in futures {\\n        info!(\\\"Future completed. Result: {:?}\\\", future.await);\\n    }\\n}\\n\\n\")), mdx(\"p\", null, \"Schema Registry for confluent : \", mdx(\"a\", {\n    \"href\": \"https://github.com/gklijs/schema_registry_converter\",\n    \"parentName\": \"p\"\n  }, \"https://github.com/gklijs/schema_registry_converter\")), mdx(\"p\", null, \"Confluent Write up : \", mdx(\"a\", {\n    \"href\": \"https://www.confluent.io/blog/getting-started-with-rust-and-kafka/\",\n    \"parentName\": \"p\"\n  }, \"https://www.confluent.io/blog/getting-started-with-rust-and-kafka/\")), mdx(\"hr\", null), mdx(\"h2\", {\n    \"id\": \"in-golang\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"In [\", mdx(\"a\", {\n    \"href\": \"golang\",\n    \"title\": \"Golang\",\n    \"parentName\": \"h2\"\n  }, \"golang\"), \"]\"), mdx(\"p\", null, \"Package : \", mdx(\"a\", {\n    \"href\": \"https://github.com/confluentinc/confluent-kafka-go\",\n    \"parentName\": \"p\"\n  }, \"Confluent Inc\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-golang\",\n    \"parentName\": \"pre\"\n  }, \"func main() {\\n\\n    p, err := kafka.NewProducer(&kafka.ConfigMap{\\\"bootstrap.servers\\\": \\\"localhost\\\"})\\n    if err != nil {\\n        panic(err)\\n    }\\n\\n    defer p.Close()\\n\\n    // Delivery report handler for produced messages\\n    go func() {\\n        for e := range p.Events() {\\n            switch ev := e.(type) {\\n            case *kafka.Message:\\n                if ev.TopicPartition.Error != nil {\\n                    fmt.Printf(\\\"Delivery failed: %v\\\\n\\\", ev.TopicPartition)\\n                } else {\\n                    fmt.Printf(\\\"Delivered message to %v\\\\n\\\", ev.TopicPartition)\\n                }\\n            }\\n        }\\n    }()\\n\\n    // Produce messages to topic (asynchronously)\\n    topic := \\\"myTopic\\\"\\n    for _, word := range []string{\\\"Welcome\\\", \\\"to\\\", \\\"the\\\", \\\"Confluent\\\", \\\"Kafka\\\", \\\"Golang\\\", \\\"client\\\"} {\\n        p.Produce(&kafka.Message{\\n            TopicPartition: kafka.TopicPartition{Topic: &topic, Partition: kafka.PartitionAny},\\n            Value:          []byte(word),\\n        }, nil)\\n    }\\n\\n    // Wait for message deliveries before shutting down\\n    p.Flush(15 * 1000)\\n}\\n\")), mdx(\"p\", null, \"Package : \", mdx(\"a\", {\n    \"href\": \"https://github.com/segmentio/kafka-go\",\n    \"parentName\": \"p\"\n  }, \"SegmentIO\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-golang\",\n    \"parentName\": \"pre\"\n  }, \"func producer() {\\n\\n    topic := \\\"my-topic\\\"\\n    partition := 0\\n\\n    conn, _ := kafka.DialLeader(context.Background(), \\\"tcp\\\", \\\"localhost:9092\\\", topic, partition)\\n\\n    conn.SetWriteDeadline(time.Now().Add(10*time.Second))\\n    conn.WriteMessages(\\n    kafka.Message{Value: []byte(\\\"one!\\\")},\\n    kafka.Message{Value: []byte(\\\"two!\\\")},\\n    kafka.Message{Value: []byte(\\\"three!\\\")},\\n    )\\n\\n    conn.Close()\\n}\\n\")), mdx(\"p\", null, \"Package : \", mdx(\"a\", {\n    \"href\": \"https://github.com/Shopify/sarama\",\n    \"parentName\": \"p\"\n  }, \"Sarama\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-golang\",\n    \"parentName\": \"pre\"\n  }, \"//Sync Producer\\nfunc newDataCollector(brokerList []string) sarama.SyncProducer {\\n\\n    // For the data collector, we are looking for strong consistency semantics.\\n    // Because we don't change the flush settings, sarama will try to produce messages\\n    // as fast as possible to keep latency low.\\n    config := sarama.NewConfig()\\n    config.Producer.RequiredAcks = sarama.WaitForAll // Wait for all in-sync replicas to ack the message\\n    config.Producer.Retry.Max = 10                   // Retry up to 10 times to produce the message\\n    config.Producer.Return.Successes = true\\n    tlsConfig := createTlsConfiguration()\\n    if tlsConfig != nil {\\n        config.Net.TLS.Config = tlsConfig\\n        config.Net.TLS.Enable = true\\n    }\\n\\n    // On the broker side, you may want to change the following settings to get\\n    // stronger consistency guarantees:\\n    // - For your broker, set `unclean.leader.election.enable` to false\\n    // - For the topic, you could increase `min.insync.replicas`.\\n\\n    producer, err := sarama.NewSyncProducer(brokerList, config)\\n    if err != nil {\\n        log.Fatalln(\\\"Failed to start Sarama producer:\\\", err)\\n    }\\n\\n    return producer\\n}\\n\\n// Async Producer\\nfunc newAccessLogProducer(brokerList []string) sarama.AsyncProducer {\\n\\n    // For the access log, we are looking for AP semantics, with high throughput.\\n    // By creating batches of compressed messages, we reduce network I/O at a cost of more latency.\\n    config := sarama.NewConfig()\\n    tlsConfig := createTlsConfiguration()\\n    if tlsConfig != nil {\\n        config.Net.TLS.Enable = true\\n        config.Net.TLS.Config = tlsConfig\\n    }\\n    config.Producer.RequiredAcks = sarama.WaitForLocal       // Only wait for the leader to ack\\n    config.Producer.Compression = sarama.CompressionSnappy   // Compress messages\\n    config.Producer.Flush.Frequency = 500 * time.Millisecond // Flush batches every 500ms\\n\\n    producer, err := sarama.NewAsyncProducer(brokerList, config)\\n    if err != nil {\\n        log.Fatalln(\\\"Failed to start Sarama producer:\\\", err)\\n    }\\n\\n    // We will just log to STDOUT if we're not able to produce messages.\\n    // Note: messages will only be returned here after all retry attempts are exhausted.\\n    go func() {\\n        for err := range producer.Errors() {\\n            log.Println(\\\"Failed to write access log entry:\\\", err)\\n        }\\n    }()\\n\\n    return producer\\n}\\n\\ngo func sendMessage(){\\n        // Synch\\n        partition, offset, err := s.DataCollector.SendMessage(&sarama.ProducerMessage{\\n            Topic: \\\"important\\\",\\n            Value: sarama.StringEncoder(r.URL.RawQuery),\\n        })\\n        // Async\\n        s.AccessLogProducer.Input() <- &sarama.ProducerMessage{\\n            Topic: \\\"access_log\\\",\\n            Key:   sarama.StringEncoder(r.RemoteAddr),\\n            Value: entry,\\n        }\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"67abd20c-6607-580b-bb55-74eeb8467444","fields":{"slug":"/producer","title":"Producer"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"consumer\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Consumer\"), mdx(\"ul\", null, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Subscribes to topics and receives message\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Consumer Group -> method of scaling consumption\"), mdx(\"ul\", {\n    \"parentName\": \"li\"\n  }, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Membership triggered by a \", mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"JoinGroup\"), \" call\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"First member is the de-facto group leader\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"leader assigns partitions to consumers in the consumer group\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Membership is maintained by sending \", mdx(\"em\", {\n    \"parentName\": \"li\"\n  }, \"heartbeats\"), \" at intervals regularly to the \", mdx(\"em\", {\n    \"parentName\": \"li\"\n  }, \"group coordinator\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Sent during \", mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"poll\"), \" and \", mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"commit\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"missing heartbeats for a period will trigger rebalance as the consumer is thought to be dead\"))), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, mdx(\"em\", {\n    \"parentName\": \"p\"\n  }, \"Rebalance\"), \" moving partition ownership from one consumer to another\"), mdx(\"ul\", {\n    \"parentName\": \"li\"\n  }, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"high scalability and availability\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"creates a short unavailability window\")))), mdx(\"p\", null), mdx(\"h1\", {\n    \"id\": \"creating-a-consumer\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Creating a Consumer\"), mdx(\"h2\", {\n    \"id\": \"in-rust\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"In [\", mdx(\"a\", {\n    \"href\": \"rust\",\n    \"title\": \"Rust\",\n    \"parentName\": \"h2\"\n  }, \"rust\"), \"]\"), mdx(\"p\", null, \"Crate : \", mdx(\"a\", {\n    \"href\": \"https://crates.io/crates/kafka\",\n    \"parentName\": \"p\"\n  }, \"kafka\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-Rust\",\n    \"parentName\": \"pre\"\n  }, \"use kafka::consumer::{Consumer, FetchOffset, GroupOffsetStorage};\\nlet mut consumer =\\n   Consumer::from_hosts(vec!(\\\"localhost:9092\\\".to_owned()))\\n      .with_topic_partitions(\\\"my-topic\\\".to_owned(), &[0, 1])\\n      .with_fallback_offset(FetchOffset::Earliest)\\n      .with_group(\\\"my-group\\\".to_owned())\\n      .with_offset_storage(GroupOffsetStorage::Kafka)\\n      .create()\\n      .unwrap();\\nloop {\\n  for ms in consumer.poll().unwrap().iter() {\\n    for m in ms.messages() {\\n      println!(\\\"{:?}\\\", m);\\n    }\\n    consumer.consume_messageset(ms);\\n  }\\n  consumer.commit_consumed().unwrap();\\n}\\n\")), mdx(\"p\", null, \"Crate : \", mdx(\"a\", {\n    \"href\": \"https://crates.io/crates/rdkafka\",\n    \"parentName\": \"p\"\n  }, \"rdkafka\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-Rust\",\n    \"parentName\": \"pre\"\n  }, \"async fn consume(brokers: &str, group_id: &str, topics: &[&str]) {\\n    let context = CustomContext;\\n\\n    let consumer: LoggingConsumer = ClientConfig::new()\\n        .set(\\\"group.id\\\", group_id)\\n        .set(\\\"bootstrap.servers\\\", brokers)\\n        .set(\\\"enable.partition.eof\\\", \\\"false\\\")\\n        .set(\\\"session.timeout.ms\\\", \\\"6000\\\")\\n        .set(\\\"enable.auto.commit\\\", \\\"true\\\")\\n        //.set(\\\"statistics.interval.ms\\\", \\\"30000\\\")\\n        //.set(\\\"auto.offset.reset\\\", \\\"smallest\\\")\\n        .set_log_level(RDKafkaLogLevel::Debug)\\n        .create_with_context(context)\\n        .expect(\\\"Consumer creation failed\\\");\\n\\n    consumer\\n        .subscribe(&topics.to_vec())\\n        .expect(\\\"Can't subscribe to specified topics\\\");\\n\\n    // consumer.start() returns a stream. The stream can be used ot chain together expensive steps,\\n    // such as complex computations on a thread pool or asynchronous IO.\\n    let mut message_stream = consumer.start();\\n\\n    while let Some(message) = message_stream.next().await {\\n        match message {\\n            Err(e) => warn!(\\\"Kafka error: {}\\\", e),\\n            Ok(m) => {\\n                let payload = match m.payload_view::<str>() {\\n                    None => \\\"\\\",\\n                    Some(Ok(s)) => s,\\n                    Some(Err(e)) => {\\n                        warn!(\\\"Error while deserializing message payload: {:?}\\\", e);\\n                        \\\"\\\"\\n                    }\\n                };\\n                info!(\\\"key: '{:?}', payload: '{}', topic: {}, partition: {}, offset: {}, timestamp: {:?}\\\",\\n                      m.key(), payload, m.topic(), m.partition(), m.offset(), m.timestamp());\\n                if let Some(headers) = m.headers() {\\n                    for i in 0..headers.count() {\\n                        let header = headers.get(i).unwrap();\\n                        info!(\\\"  Header {:#?}: {:?}\\\", header.0, header.1);\\n                    }\\n                }\\n                consumer.commit_message(&m, CommitMode::Async).unwrap();\\n            }\\n        };\\n    }\\n}\\n\")), mdx(\"hr\", null), mdx(\"h2\", {\n    \"id\": \"in-golang\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"In [\", mdx(\"a\", {\n    \"href\": \"golang\",\n    \"title\": \"Golang\",\n    \"parentName\": \"h2\"\n  }, \"golang\"), \"]\"), mdx(\"p\", null, \"Package : \", mdx(\"a\", {\n    \"href\": \"https://github.com/confluentinc/confluent-kafka-go\",\n    \"parentName\": \"p\"\n  }, \"Confluent Inc\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-golang\",\n    \"parentName\": \"pre\"\n  }, \"func main() {\\n\\n    c, err := kafka.NewConsumer(&kafka.ConfigMap{\\n        \\\"bootstrap.servers\\\": \\\"localhost\\\",\\n        \\\"group.id\\\":          \\\"myGroup\\\",\\n        \\\"auto.offset.reset\\\": \\\"earliest\\\",\\n    })\\n\\n    if err != nil {\\n        panic(err)\\n    }\\n\\n    c.SubscribeTopics([]string{\\\"myTopic\\\", \\\"^aRegex.*[Tt]opic\\\"}, nil)\\n\\n    for {\\n        msg, err := c.ReadMessage(-1)\\n        if err == nil {\\n            fmt.Printf(\\\"Message on %s: %s\\\\n\\\", msg.TopicPartition, string(msg.Value))\\n        } else {\\n            // The client will automatically try to recover from all errors.\\n            fmt.Printf(\\\"Consumer error: %v (%v)\\\\n\\\", err, msg)\\n        }\\n    }\\n\\n    c.Close()\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"package--segmentio\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Package : \", mdx(\"a\", {\n    \"href\": \"https://github.com/segmentio/kafka-go\",\n    \"parentName\": \"h2\"\n  }, \"SegmentIO\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-golang\",\n    \"parentName\": \"pre\"\n  }, \"func consumer(){}\\nr := kafka.NewReader(kafka.ReaderConfig{\\n    Brokers:   []string{\\\"localhost:9092\\\"},\\n    Topic:     \\\"topic-A\\\",\\n    Partition: 0,\\n    MinBytes:  10e3, // 10KB\\n    MaxBytes:  10e6, // 10MB\\n})\\nr.SetOffset(42)\\n\\nfor {\\n    m, err := r.ReadMessage(context.Background())\\n    if err != nil {\\n        break\\n    }\\n    fmt.Printf(\\\"message at offset %d: %s = %s\\\\n\\\", m.Offset, string(m.Key), string(m.Value))\\n}\\n\\nr.Close()\\n}\\n\")), mdx(\"p\", null, \"Package : \", mdx(\"a\", {\n    \"href\": \"https://github.com/Shopify/sarama\",\n    \"parentName\": \"p\"\n  }, \"Sarama\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-golang\",\n    \"parentName\": \"pre\"\n  }, \"// ConsumeClaim must start a consumer loop of ConsumerGroupClaim's Messages().\\nfunc (consumer *Consumer) ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {\\n\\n    // NOTE:\\n    // Do not move the code below to a goroutine.\\n    // The `ConsumeClaim` itself is called within a goroutine, see:\\n    // https://github.com/Shopify/sarama/blob/master/consumer_group.go#L27-L29\\n    for message := range claim.Messages() {\\n        log.Printf(\\\"Message claimed: value = %s, timestamp = %v, topic = %s\\\", string(message.Value), message.Timestamp, message.Topic)\\n        session.MarkMessage(message, \\\"\\\")\\n    }\\n\\n    return nil\\n}\\n\\ngo func() comsumer{\\n        defer wg.Done()\\n        for {\\n            // `Consume` should be called inside an infinite loop, when a\\n            // server-side rebalance happens, the consumer session will need to be\\n            // recreated to get the new claims\\n            if err := client.Consume(ctx, strings.Split(topics, \\\",\\\"), &consumer); err != nil {\\n                log.Panicf(\\\"Error from consumer: %v\\\", err)\\n            }\\n            // check if context was cancelled, signaling that the consumer should stop\\n            if ctx.Err() != nil {\\n                return\\n            }\\n            consumer.ready = make(chan bool)\\n        }\\n    }()\\n\\n\")), mdx(\"h1\", {\n    \"id\": \"commits\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Commits\"), mdx(\"ul\", null, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Consumers use kafka to track their position in each partition\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"commit\"), \" act of updating current position in kafka\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"message \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"__consumer_offsets\"), \" topic with the offset for each partition\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"when rebalance each consumer receives a new partition and obtains the latest committed offset from where to start reading\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Commit Strategy\"), mdx(\"ul\", {\n    \"parentName\": \"li\"\n  }, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Automatic\"), mdx(\"ul\", {\n    \"parentName\": \"li\"\n  }, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Done by consumer every 5 seconds configurable\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Commits largest offset from \", mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"poll\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"call to \", mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"poll\"), \" will always commit the last offset\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"results in double processing if \", mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"rebalance\"), \" occurs in between a 5 sec window\"))), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Commit Current Offset\"), mdx(\"ul\", {\n    \"parentName\": \"li\"\n  }, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Gives control to the developer\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"commitSync\"), \" triggers commit of the last offset returned by \", mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"poll\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"must be called after processing all messages\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Synchronous call blocks the application\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Auto retry till success of non retry-able failure\"))), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Asynchronous Commit\"), mdx(\"ul\", {\n    \"parentName\": \"li\"\n  }, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Fire and forget till we get a callback\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Does not auto retry as a later commit request might have latest Offset\"))), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Async + Sync Commit\"), mdx(\"ul\", {\n    \"parentName\": \"li\"\n  }, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"CommitAsync\"), \" always\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Trigger a CommitSync just before exit\")))))));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"a9f33b82-4aa7-599b-a242-54db28ac76f1","fields":{"slug":"/consumer","title":"Consumer"}}}]},"fields":{"slug":"/rust","title":"Rust"}}},"pageContext":{"id":"80160a7b-29c9-59fa-866f-c39ebab1da04"}},"staticQueryHashes":["2098632890","426988268"]}