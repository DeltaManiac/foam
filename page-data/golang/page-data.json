{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/golang","result":{"data":{"file":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"golang\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Golang\"), mdx(\"h2\", {\n    \"id\": \"web-dev\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Web Dev\"), mdx(\"p\", null, \"[\", mdx(\"a\", {\n    \"href\": \"gokit\",\n    \"title\": \"Gokit\",\n    \"parentName\": \"p\"\n  }, \"gokit\"), \"]\"), mdx(\"h2\", {\n    \"id\": \"kafka\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Kafka\"), mdx(\"p\", null, \"Kafka [\", mdx(\"a\", {\n    \"href\": \"producer\",\n    \"title\": \"Producer\",\n    \"parentName\": \"p\"\n  }, \"producer\"), \"]\"), mdx(\"p\", null, \"Kafka [\", mdx(\"a\", {\n    \"href\": \"consumer\",\n    \"title\": \"Consumer\",\n    \"parentName\": \"p\"\n  }, \"consumer\"), \"]\"));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"gokit\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Gokit\"), mdx(\"p\", null, \"Spring boot like framework for [\", mdx(\"a\", {\n    \"href\": \"golang\",\n    \"title\": \"Golang\",\n    \"parentName\": \"p\"\n  }, \"golang\"), \"]. It has 3 major Components\"), mdx(\"h2\", {\n    \"id\": \"service-layer\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Service Layer\"), mdx(\"ul\", null, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Innermost layer where business logic resides.\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Modeled as services\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Oblivious to Endpoint/Transport Layers\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Can be used by multiple Transports (grpc/json/http)\")), mdx(\"h2\", {\n    \"id\": \"endpoint-layer\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Endpoint Layer\"), mdx(\"ul\", null, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Represents a single RPC Method\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Service exposed as an Endpoint\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Endpoint can be exposed by multiple Transports\")), mdx(\"h2\", {\n    \"id\": \"transport-layer\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Transport Layer\"), mdx(\"ul\", null, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Exposes various Transports\", mdx(\"ul\", {\n    \"parentName\": \"li\"\n  }, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"grpc\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"http\")))), mdx(\"h1\", {\n    \"id\": \"building-a-pastebin-clone\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Building a \", mdx(\"inlineCode\", {\n    \"parentName\": \"h1\"\n  }, \"pastebin\"), \" clone\"), mdx(\"h2\", {\n    \"id\": \"define-a-service-blueprint-interface\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Define a service blueprint interface\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"// PbService provides storage capabilities\\ntype PbService interface {\\n    Create(content string, ctx context.Context) (string, error)\\n    Delete(key string, ctx context.Context) (string, error)\\n    Get(key string, ctx context.Context) (string, error)\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"make-a-new-struct-to-define-the-pastebin-service\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Make a new struct to define the PasteBin Service\"), mdx(\"p\", null, \"This struct is used to group together the functionalities of pastebin service\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"type pbService struct {\\n    memory map[uuid.UUID]string\\n}\\n\\n// NewPbService make a new PbService\\nfunc NewPbService() PbService {\\n    return pbService{\\n        memory: make(map[uuid.UUID]string),\\n    }\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"implement-the-pbservice-interface-on-the-struct\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Implement the PbService Interface on the struct\"), mdx(\"p\", null, \"In [\", mdx(\"a\", {\n    \"href\": \"golang\",\n    \"title\": \"Golang\",\n    \"parentName\": \"p\"\n  }, \"golang\"), \"] we do not have a key word to define that this structs implements a specific interface like the \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"implements\"), \" in Java.\"), mdx(\"p\", null, \"They way we enforce contracts is by implementing all the methods of the contract interface in our case here its the \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"PbService\"), \" interface.\"), mdx(\"p\", null, \"Since our \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"NewPbService\"), \" method returns the type of \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"PbService\"), \" the go compiler will ensure that \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"NewPbService\"), \" confirms to the \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"PbService\"), \" interface.\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"//Create: Here we store the content and return a uuid\\nfunc (s pbService) Create(ctx context.Context, content string) (string, error) {\\n    id := uuid.New()\\n    s.memory[id] = content\\n    return id.String(), nil\\n}\\n\\n//Delete: Here we use the key to find and delete the content stored\\nfunc (s pbService) Delete(ctx context.Context, key string) (string, error) {\\n    id, err := uuid.Parse(key)\\n    if err != nil {\\n        return \\\"\\\", errors.New(\\\"Invalid Uuid Format\\\")\\n    }\\n    delete(s.memory, id)\\n    return \\\"ok\\\", nil\\n}\\n\\n//Get: Here we use the key to find and return the content stored\\nfunc (s pbService) Get(ctx context.Context, key string) (string, error) {\\n    id, err := uuid.Parse(key)\\n    if err != nil {\\n        return \\\"\\\", errors.New(\\\"Invalid Uuid Format\\\")\\n    }\\n    content, exists := s.memory[id]\\n    if exists {\\n        return content, nil\\n    }\\n    return \\\"\\\", errors.New(\\\"Invalid Uuid\\\")\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"request-and-response\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Request and Response\"), mdx(\"p\", null, \"In Go kit, the primary messaging pattern is RPC.\"), mdx(\"p\", null, \"So, every method in our interface will be modeled as a remote procedure call. For each method, we define request and response structs, capturing all of the input and output parameters respectively.\"), mdx(\"h3\", {\n    \"id\": \"create-request-response\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Create Request Response\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"type createPbRequest struct {\\n    content string `json:\\\"content\\\"`\\n}\\n\\ntype createPbResponse struct {\\n    key string `json:\\\"key\\\"`\\n    Err string `json:\\\"err,omitempty\\\"` // errors don't JSON-marshal, so we use a string\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"delete-request-response\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Delete Request Response\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"type deletePbRequest struct {\\n    key string `json:\\\"key\\\"`\\n}\\n\\ntype deletePbResponse struct {\\n    status string `json:\\\"status\\\"`\\n    Err    string `json:\\\"err,omitempty\\\"` // errors don't JSON-marshal, so we use a string\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"get-request-response\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Get Request Response\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"type getPbRequest struct {\\n    key string `json:\\\"key\\\"`\\n}\\n\\ntype getPbResponse struct {\\n    content string `json:\\\"content\\\"`\\n    Err     string `json:\\\"err,omitempty\\\"` // errors don't JSON-marshal, so we use a string\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"define-endpoints\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Define Endpoints\"), mdx(\"p\", null, \"An endpoint represents a single RPC, which is a single method in our service.\"), mdx(\"h3\", {\n    \"id\": \"create-endpoint\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Create Endpoint\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"func createPbEndpoint(svc PbService) endpoint.Endpoint {\\n    return func(ctx context.Context, request interface{}) (interface{}, error) {\\n        req := request.(createPbRequest)\\n        key, err := svc.Create(ctx, req.Content)\\n        if err != nil {\\n            return createPbResponse{key, err.Error()}, nil\\n        }\\n        return createPbResponse{key, \\\"\\\"}, nil\\n    }\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"delete-endpoint\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Delete Endpoint\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"func deletePbEndpoint(svc PbService) endpoint.Endpoint {\\n    return func(ctx context.Context, request interface{}) (interface{}, error) {\\n        req := request.(deletePbRequest)\\n        status, err := svc.Delete(ctx, req.Key)\\n        if err != nil {\\n            return deletePbResponse{status, err.Error()}, nil\\n        }\\n        return deletePbResponse{status, \\\"\\\"}, nil\\n    }\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"get-endpoint\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Get Endpoint\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"func getPbEndpoint(svc PbService) endpoint.Endpoint {\\n    return func(ctx context.Context, request interface{}) (interface{}, error) {\\n        req := request.(getPbRequest)\\n        content, err := svc.Get(ctx, req.Key)\\n        if err != nil {\\n            return getPbResponse{content, err.Error()}, nil\\n        }\\n        return getPbResponse{content, \\\"\\\"}, nil\\n    }\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"define-transport\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Define Transport\"), mdx(\"p\", null, \"Since this trivial example used JSON over HTTP we would have to decode the JSON to structs that our service can understand\"), mdx(\"h3\", {\n    \"id\": \"create-requester-decoder\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Create Requester Decoder\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"func decodeCreatePbRequest(_ context.Context, r *http.Request) (interface{}, error) {\\n    var request createPbRequest\\n    if err := json.NewDecoder(r.Body).Decode(&request); err != nil {\\n        return nil, err\\n    }\\n    return request, nil\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"delete-request-decoder\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Delete Request Decoder\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"func decodeDeletePbRequest(_ context.Context, r *http.Request) (interface{}, error) {\\n    var request deletePbRequest\\n    if err := json.NewDecoder(r.Body).Decode(&request); err != nil {\\n        return nil, err\\n    }\\n    return request, nil\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"get-request-decoder\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Get Request Decoder\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"func decodeGetPbRequest(_ context.Context, r *http.Request) (interface{}, error) {\\n    var request getPbRequest\\n    if err := json.NewDecoder(r.Body).Decode(&request); err != nil {\\n        return nil, err\\n    }\\n    return request, nil\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"response-encoder\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Response Encoder\"), mdx(\"p\", null, \"This method would accept an \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"interface\"), \" type and convert it JSON, this allows it to accept \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"createPbResponse\"), \",\", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"deletePbResponse\"), \",\", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"getPbResponse\"), \" as an \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"interface{}\"), \" and encode it as json using the annotations in the struct definition.\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"func encodeResponse(_ context.Context, w http.ResponseWriter, response interface{}) error {\\n    return json.NewEncoder(w).Encode(response)\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"main\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Main\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"import (\\n    \\\"context\\\"\\n    \\\"encoding/json\\\"\\n    \\\"errors\\\"\\n    \\\"log\\\"\\n    \\\"net/http\\\"\\n\\n    \\\"github.com/go-kit/kit/endpoint\\\"\\n    \\\"github.com/google/uuid\\\"\\n\\n    httptransport \\\"github.com/go-kit/kit/transport/http\\\"\\n)\\n\\nfunc main() {\\n    svc := NewPbService()\\n    createPbHandler := httptransport.NewServer(\\n        createPbEndpoint(svc),\\n        decodeCreatePbRequest,\\n        encodeResponse,\\n    )\\n\\n    deletePbHandler := httptransport.NewServer(\\n        deletePbEndpoint(svc),\\n        decodeDeletePbRequest,\\n        encodeResponse,\\n    )\\n    \\n    getPbHandler := httptransport.NewServer(\\n        getPbEndpoint(svc),\\n        decodeGetPbRequest,\\n        encodeResponse,\\n    )\\n    \\n    http.Handle(\\\"/create\\\", createPbHandler)\\n    http.Handle(\\\"/delete\\\", deletePbHandler)\\n    http.Handle(\\\"/get\\\", getPbHandler)\\n    log.Fatal(http.ListenAndServe(\\\":8080\\\", nil))\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"divide-and-conquer\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Divide and Conquer\"), mdx(\"p\", null, \"At this point the \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"main.go\"), \" has a lot of code so lets move to different files so that we have separation of concerns.\"), mdx(\"h3\", {\n    \"id\": \"servicego\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"inlineCode\", {\n    \"parentName\": \"h3\"\n  }, \"service.go\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"package main\\n\\nimport (\\n    \\\"context\\\"\\n    \\\"errors\\\"\\n\\n    \\\"github.com/google/uuid\\\"\\n)\\n\\n// PbService provides storage capabilities\\ntype PbService interface {\\n    Create(ctx context.Context, content string) (string, error)\\n    Delete(ctx context.Context, key string) (string, error)\\n    Get(ctx context.Context, key string) (string, error)\\n}\\n\\ntype pbService struct {\\n    memory map[uuid.UUID]string\\n}\\n\\n// NewPbService make a new PbService\\nfunc NewPbService() PbService {\\n    return pbService{\\n        memory: make(map[uuid.UUID]string),\\n    }\\n}\\n\\n//Create: Here we store the content and return a uuid\\nfunc (s pbService) Create(ctx context.Context, content string) (string, error) {\\n    id := uuid.New()\\n    s.memory[id] = content\\n    return id.String(), nil\\n}\\n\\n//Get: Here we use the key to find and return the content stored\\nfunc (s pbService) Get(ctx context.Context, key string) (string, error) {\\n    id, err := uuid.Parse(key)\\n    if err != nil {\\n        return \\\"\\\", errors.New(\\\"Invalid Uuid Format\\\")\\n    }\\n    content, exists := s.memory[id]\\n    if exists {\\n        return content, nil\\n    }\\n    return \\\"\\\", errors.New(\\\"Invalid Uuid\\\")\\n}\\n\\n//Delete: Here we use the key to find and delete the content stored\\nfunc (s pbService) Delete(ctx context.Context, key string) (string, error) {\\n    id, err := uuid.Parse(key)\\n    if err != nil {\\n        return \\\"\\\", errors.New(\\\"Invalid Uuid Format\\\")\\n    }\\n    delete(s.memory, id)\\n    return \\\"ok\\\", nil\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"transportgo\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"inlineCode\", {\n    \"parentName\": \"h3\"\n  }, \"transport.go\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"package main\\n\\nimport (\\n    \\\"context\\\"\\n    \\\"encoding/json\\\"\\n    \\\"net/http\\\"\\n\\n    \\\"github.com/go-kit/kit/endpoint\\\"\\n)\\n\\ntype createPbRequest struct {\\n    Content string `json:\\\"content\\\"`\\n}\\n\\ntype createPbResponse struct {\\n    Key string `json:\\\"key\\\"`\\n    Err string `json:\\\"err,omitempty\\\"` // errors don't JSON-marshal, so we use a string\\n}\\n\\ntype getPbRequest struct {\\n    Key string `json:\\\"key\\\"`\\n}\\n\\ntype getPbResponse struct {\\n    Content string `json:\\\"content\\\"`\\n    Err     string `json:\\\"err,omitempty\\\"` // errors don't JSON-marshal, so we use a string\\n}\\n\\ntype deletePbRequest struct {\\n    Key string `json:\\\"key\\\"`\\n}\\n\\ntype deletePbResponse struct {\\n    Status string `json:\\\"status\\\"`\\n    Err    string `json:\\\"err,omitempty\\\"` // errors don't JSON-marshal, so we use a string\\n}\\n\\nfunc createPbEndpoint(svc PbService) endpoint.Endpoint {\\n    return func(ctx context.Context, request interface{}) (interface{}, error) {\\n        req := request.(createPbRequest)\\n        key, err := svc.Create(ctx, req.Content)\\n        if err != nil {\\n            return createPbResponse{key, err.Error()}, nil\\n        }\\n        return createPbResponse{key, \\\"\\\"}, nil\\n    }\\n}\\n\\nfunc deletePbEndpoint(svc PbService) endpoint.Endpoint {\\n    return func(ctx context.Context, request interface{}) (interface{}, error) {\\n        req := request.(deletePbRequest)\\n        status, err := svc.Delete(ctx, req.Key)\\n        if err != nil {\\n            return deletePbResponse{status, err.Error()}, nil\\n        }\\n        return deletePbResponse{status, \\\"\\\"}, nil\\n    }\\n}\\n\\nfunc getPbEndpoint(svc PbService) endpoint.Endpoint {\\n    return func(ctx context.Context, request interface{}) (interface{}, error) {\\n        req := request.(getPbRequest)\\n        content, err := svc.Get(ctx, req.Key)\\n        if err != nil {\\n            return getPbResponse{content, err.Error()}, nil\\n        }\\n        return getPbResponse{content, \\\"\\\"}, nil\\n    }\\n}\\n\\nfunc decodeCreatePbRequest(_ context.Context, r *http.Request) (interface{}, error) {\\n    var request createPbRequest\\n    if err := json.NewDecoder(r.Body).Decode(&request); err != nil {\\n        return nil, err\\n    }\\n    return request, nil\\n}\\n\\nfunc decodeGetPbRequest(_ context.Context, r *http.Request) (interface{}, error) {\\n    var request getPbRequest\\n    if err := json.NewDecoder(r.Body).Decode(&request); err != nil {\\n        return nil, err\\n    }\\n    return request, nil\\n}\\n\\nfunc decodeDeletePbRequest(_ context.Context, r *http.Request) (interface{}, error) {\\n    var request deletePbRequest\\n    if err := json.NewDecoder(r.Body).Decode(&request); err != nil {\\n        return nil, err\\n    }\\n    return request, nil\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"maingo\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"inlineCode\", {\n    \"parentName\": \"h3\"\n  }, \"main.go\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"func main() {\\n    svc := NewPbService()\\n    createPbHandler := httptransport.NewServer(\\n        createPbEndpoint(svc),\\n        decodeCreatePbRequest,\\n        encodeResponse,\\n    )\\n\\n    deletePbHandler := httptransport.NewServer(\\n        deletePbEndpoint(svc),\\n        decodeDeletePbRequest,\\n        encodeResponse,\\n    )\\n    getPbHandler := httptransport.NewServer(\\n        getPbEndpoint(svc),\\n        decodeGetPbRequest,\\n        encodeResponse,\\n    )\\n    http.Handle(\\\"/create\\\", createPbHandler)\\n    http.Handle(\\\"/delete\\\", deletePbHandler)\\n    http.Handle(\\\"/get\\\", getPbHandler)\\n    log.Fatal(http.ListenAndServe(\\\":8080\\\", nil))\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"logging-middleware\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Logging Middleware\"), mdx(\"p\", null, \"All applications need to log information, this can be enabled by adding a logging middleware that we create in a file called \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"logging.go\")), mdx(\"p\", null, \"Middleware in go-kit work on \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"Endpoint\")), mdx(\"p\", null, \"The interface definition is \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"type Middleware func(Endpoint) Endpoint\"), \", which means it is a function that takes in an endpoint and returns an endpoint\"), mdx(\"p\", null, \"We can create the \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"loggingMiddleware\"), \" so that it adheres to the \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"PbService\"), \" by implementing the \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"Create\"), \" \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"Delete\"), \" \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"Get\"), \" methods.\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"type loggingMiddleware struct {\\n    logger log.Logger\\n    next   PbService\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"create\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Create\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"func (m loggingMiddleware) Create(ctx context.Context, content string) (output string, err error) {\\n    // This defered function would be invoked just before the retuen statement\\n    defer func(begin time.Time) {\\n        m.logger.Log(\\n            \\\"method\\\", \\\"CreatePb\\\",\\n            \\\"input\\\", content,\\n            \\\"output\\\", output,\\n            \\\"err\\\", err,\\n            \\\"took\\\", time.Since(begin),\\n        )\\n    }(time.Now())\\n    output, err = m.next.Create(ctx, content)\\n    return\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"delete\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Delete\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \" func (m loggingMiddleware) Delete(ctx context.Context, key string) (output string, err error) {\\n    defer func(begin time.Time) {\\n        m.logger.Log(\\n            \\\"method\\\", \\\"DeletePb\\\",\\n            \\\"input\\\", key,\\n            \\\"output\\\", output,\\n            \\\"err\\\", err,\\n            \\\"took\\\", time.Since(begin),\\n        )\\n    }(time.Now())\\n    output, err = m.next.Delete(ctx, key)\\n    return\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"get\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Get\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"func (m loggingMiddleware) Get(ctx context.Context, key string) (output string, err error) {\\n    defer func(begin time.Time) {\\n        m.logger.Log(\\n            \\\"method\\\", \\\"GetPb\\\",\\n            \\\"input\\\", key,\\n            \\\"output\\\", output,\\n            \\\"err\\\", err,\\n            \\\"took\\\", time.Since(begin),\\n        )\\n    }(time.Now())\\n    output, err = m.next.Get(ctx, key)\\n    return\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"wiring-the-middleware\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Wiring the Middleware\"), mdx(\"p\", null, \"In order to wire the middleware in all we have to do is link it up with the service that we have defined\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"package main\\n\\nimport (\\n    \\\"context\\\"\\n    \\\"encoding/json\\\"\\n    \\\"net/http\\\"\\n    \\\"os\\\"\\n\\n    \\\"github.com/go-kit/kit/log\\\"\\n\\n    httptransport \\\"github.com/go-kit/kit/transport/http\\\"\\n)\\n\\nfunc main() {\\n    // Use the global logger\\n    logger := log.NewLogfmtLogger(os.Stderr)\\n    var svc PbService\\n    svc = NewPbService()\\n    // Wire the middleware and thats it\\n    svc = loggingMiddleware{logger, svc}\\n\\n    createPbHandler := httptransport.NewServer(\\n        createPbEndpoint(svc),\\n        decodeCreatePbRequest,\\n        encodeResponse,\\n    )\\n\\n    deletePbHandler := httptransport.NewServer(\\n        deletePbEndpoint(svc),\\n        decodeDeletePbRequest,\\n        encodeResponse,\\n    )\\n\\n    getPbHandler := httptransport.NewServer(\\n        getPbEndpoint(svc),\\n        decodeGetPbRequest,\\n        encodeResponse,\\n    )\\n    http.Handle(\\\"/create\\\", createPbHandler)\\n    http.Handle(\\\"/delete\\\", deletePbHandler)\\n    http.Handle(\\\"/get\\\", getPbHandler)\\n    logger.Log(\\\"msg\\\", \\\"HTTP\\\", \\\"addr\\\", \\\":8080\\\")\\n    logger.Log(\\\"err\\\", http.ListenAndServe(\\\":8080\\\", nil))\\n}\\n\\nfunc encodeResponse(_ context.Context, w http.ResponseWriter, response interface{}) error {\\n    return json.NewEncoder(w).Encode(response)\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"pastebin\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"PasteBin\"), mdx(\"h3\", {\n    \"id\": \"client\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Client\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-sh\",\n    \"parentName\": \"pre\"\n  }, \"\\n$ curl localhost:8080/create -XPOST -d '{\\\"content\\\":\\\"THIS IS SPARTA\\\"}'\\n\\n{\\\"key\\\":\\\"c449250a-d74c-4d23-acbb-6785b0bd822a\\\"} \\n\\n$ curl localhost:8080/get -XPOST -d '{\\\"key\\\":\\\"c449250a-d74c-4d23-acbb-6785b0bd822a\\\"}'\\n\\n{\\\"content\\\":\\\"THIS IS SPARTA\\\"}\\n\\n$ curl localhost:8I00/delete -XPOST -d '{\\\"key\\\":\\\"c449250a-d74c-4d23-acbb-6785b0bd822a\\\"}'\\n\\n{\\\"status\\\":\\\"ok\\\"}\\n\\n$ curl localhost:8080/get -XPOST -d '{\\\"key\\\":\\\"c449250a-d74c-4d23-acbb-6785b0bd822a\\\"}'\\n\\n{\\\"content\\\":\\\"\\\",\\\"err\\\":\\\"Invalid Uuid\\\"}\\n\\n\")), mdx(\"h3\", {\n    \"id\": \"server\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Server\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-sh\",\n    \"parentName\": \"pre\"\n  }, \"$ ./pastebin-II \\n\\nmsg=HTTP addr=:8080\\n\\nmethod=CreatePb input=\\\"THIS IS SPARTA\\\" output=c449250a-d74c-4d23-acbb-6785b0bd822a err=null took=67.92\\xB5s\\n\\nmethod=GetPb input=c449250a-d74c-4d23-acbb-6785b0bd822a output=\\\"THIS IS SPARTA\\\" err=null took=1.675\\xB5s\\n\\nmethod=DeletePb input=c449250a-d74c-4d23-acbb-6785b0bd822a output=ok err=null took=1.45\\xB5s\\n\\nmethod=GetPb input=c449250a-d74c-4d23-acbb-6785b0bd822a output= err=\\\"Invalid Uuid\\\" took=803ns\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"7afde6b3-d4de-54bb-8c90-665201f30ec2","fields":{"slug":"/gokit","title":"Gokit"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"producer\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Producer\"), mdx(\"p\", null, \"Kafka has a binary wire protocol.This means that it is possible for applications to read messages from Kafka or write messages to Kafka simply by sending the correct byte sequences to Kafka\\u2019s network port.\"), mdx(\"p\", null, \"Key Structure is \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"ProducerRecord\")), mdx(\"p\", null), mdx(\"h1\", {\n    \"id\": \"serializer\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Serializer\"), mdx(\"p\", null, \"Converts between wire format and code\"), mdx(\"p\", null, mdx(\"a\", {\n    \"href\": \"https://https://avro.apache.org/docs/current\",\n    \"parentName\": \"p\"\n  }, \"Apache Avro\"), \"\\nDefine a common schema for serialization and deserialization\\nStore in schema Registry\\nStore schema identifier in produced message\\n\"), mdx(\"h1\", {\n    \"id\": \"creating-a-producer\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Creating a Producer\"), mdx(\"h2\", {\n    \"id\": \"in-rust\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"In [\", mdx(\"a\", {\n    \"href\": \"rust\",\n    \"title\": \"Rust\",\n    \"parentName\": \"h2\"\n  }, \"rust\"), \"]\"), mdx(\"p\", null, \"Crate : \", mdx(\"a\", {\n    \"href\": \"https://crates.io/crates/kafka\",\n    \"parentName\": \"p\"\n  }, \"kafka\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-rust\",\n    \"parentName\": \"pre\"\n  }, \"/// Producer Code\\nuse std::fmt::Write;\\nuse std::time::Duration;\\nuse kafka::producer::{Producer, Record, RequiredAcks};\\n\\nlet mut producer = Producer::from_hosts(vec!(\\\"localhost:9092\\\".to_owned()))\\n.with_ack_timeout(Duration::from_secs(1))\\n.with_required_acks(RequiredAcks::One)\\n.create()\\n.unwrap();\\n\\nlet mut buf = String::with*capacity(2);\\nfor i in 0..10 {\\nlet * = write!(&mut buf, \\\"{}\\\", i); // some computation of the message data to be sent\\nproducer.send(&Record::from_value(\\\"my-topic\\\", buf.as_bytes())).unwrap();\\nbuf.clear();\\n}\\n\")), mdx(\"p\", null, \"Crate : \", mdx(\"a\", {\n    \"href\": \"https://crates.io/crates/rdkafka\",\n    \"parentName\": \"p\"\n  }, \"rdkafka\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-Rust\",\n    \"parentName\": \"pre\"\n  }, \" sync fn produce(brokers: &str, topic_name: &str) {\\n    let producer: &FutureProducer = &ClientConfig::new()\\n        .set(\\\"bootstrap.servers\\\", brokers)\\n        .set(\\\"message.timeout.ms\\\", \\\"5000\\\")\\n        .create()\\n        .expect(\\\"Producer creation error\\\");\\n\\n    // This loop is non blocking: all messages will be sent one after the other, without waiting\\n    // for the results.\\n    let futures = (0..5)\\n        .map(|i| async move {\\n            // The send operation on the topic returns a future, which will be\\n            // completed once the result or failure from Kafka is received.\\n            let delivery_status = producer\\n                .send(\\n                    FutureRecord::to(topic_name)\\n                        .payload(&format!(\\\"Message {}\\\", i))\\n                        .key(&format!(\\\"Key {}\\\", i))\\n                        .headers(OwnedHeaders::new().add(\\\"header_key\\\", \\\"header_value\\\")),\\n                    Duration::from_secs(0),\\n                )\\n                .await;\\n\\n            // This will be executed when the result is received.\\n            info!(\\\"Delivery status for message {} received\\\", i);\\n            delivery_status\\n        })\\n        .collect::<Vec<_>>();\\n\\n    // This loop will wait until all delivery statuses have been received.\\n    for future in futures {\\n        info!(\\\"Future completed. Result: {:?}\\\", future.await);\\n    }\\n}\\n\\n\")), mdx(\"p\", null, \"Schema Registry for confluent : \", mdx(\"a\", {\n    \"href\": \"https://github.com/gklijs/schema_registry_converter\",\n    \"parentName\": \"p\"\n  }, \"https://github.com/gklijs/schema_registry_converter\")), mdx(\"p\", null, \"Confluent Write up : \", mdx(\"a\", {\n    \"href\": \"https://www.confluent.io/blog/getting-started-with-rust-and-kafka/\",\n    \"parentName\": \"p\"\n  }, \"https://www.confluent.io/blog/getting-started-with-rust-and-kafka/\")), mdx(\"hr\", null), mdx(\"h2\", {\n    \"id\": \"in-golang\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"In [\", mdx(\"a\", {\n    \"href\": \"golang\",\n    \"title\": \"Golang\",\n    \"parentName\": \"h2\"\n  }, \"golang\"), \"]\"), mdx(\"p\", null, \"Package : \", mdx(\"a\", {\n    \"href\": \"https://github.com/confluentinc/confluent-kafka-go\",\n    \"parentName\": \"p\"\n  }, \"Confluent Inc\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-golang\",\n    \"parentName\": \"pre\"\n  }, \"func main() {\\n\\n    p, err := kafka.NewProducer(&kafka.ConfigMap{\\\"bootstrap.servers\\\": \\\"localhost\\\"})\\n    if err != nil {\\n        panic(err)\\n    }\\n\\n    defer p.Close()\\n\\n    // Delivery report handler for produced messages\\n    go func() {\\n        for e := range p.Events() {\\n            switch ev := e.(type) {\\n            case *kafka.Message:\\n                if ev.TopicPartition.Error != nil {\\n                    fmt.Printf(\\\"Delivery failed: %v\\\\n\\\", ev.TopicPartition)\\n                } else {\\n                    fmt.Printf(\\\"Delivered message to %v\\\\n\\\", ev.TopicPartition)\\n                }\\n            }\\n        }\\n    }()\\n\\n    // Produce messages to topic (asynchronously)\\n    topic := \\\"myTopic\\\"\\n    for _, word := range []string{\\\"Welcome\\\", \\\"to\\\", \\\"the\\\", \\\"Confluent\\\", \\\"Kafka\\\", \\\"Golang\\\", \\\"client\\\"} {\\n        p.Produce(&kafka.Message{\\n            TopicPartition: kafka.TopicPartition{Topic: &topic, Partition: kafka.PartitionAny},\\n            Value:          []byte(word),\\n        }, nil)\\n    }\\n\\n    // Wait for message deliveries before shutting down\\n    p.Flush(15 * 1000)\\n}\\n\")), mdx(\"p\", null, \"Package : \", mdx(\"a\", {\n    \"href\": \"https://github.com/segmentio/kafka-go\",\n    \"parentName\": \"p\"\n  }, \"SegmentIO\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-golang\",\n    \"parentName\": \"pre\"\n  }, \"func producer() {\\n\\n    topic := \\\"my-topic\\\"\\n    partition := 0\\n\\n    conn, _ := kafka.DialLeader(context.Background(), \\\"tcp\\\", \\\"localhost:9092\\\", topic, partition)\\n\\n    conn.SetWriteDeadline(time.Now().Add(10*time.Second))\\n    conn.WriteMessages(\\n    kafka.Message{Value: []byte(\\\"one!\\\")},\\n    kafka.Message{Value: []byte(\\\"two!\\\")},\\n    kafka.Message{Value: []byte(\\\"three!\\\")},\\n    )\\n\\n    conn.Close()\\n}\\n\")), mdx(\"p\", null, \"Package : \", mdx(\"a\", {\n    \"href\": \"https://github.com/Shopify/sarama\",\n    \"parentName\": \"p\"\n  }, \"Sarama\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-golang\",\n    \"parentName\": \"pre\"\n  }, \"//Sync Producer\\nfunc newDataCollector(brokerList []string) sarama.SyncProducer {\\n\\n    // For the data collector, we are looking for strong consistency semantics.\\n    // Because we don't change the flush settings, sarama will try to produce messages\\n    // as fast as possible to keep latency low.\\n    config := sarama.NewConfig()\\n    config.Producer.RequiredAcks = sarama.WaitForAll // Wait for all in-sync replicas to ack the message\\n    config.Producer.Retry.Max = 10                   // Retry up to 10 times to produce the message\\n    config.Producer.Return.Successes = true\\n    tlsConfig := createTlsConfiguration()\\n    if tlsConfig != nil {\\n        config.Net.TLS.Config = tlsConfig\\n        config.Net.TLS.Enable = true\\n    }\\n\\n    // On the broker side, you may want to change the following settings to get\\n    // stronger consistency guarantees:\\n    // - For your broker, set `unclean.leader.election.enable` to false\\n    // - For the topic, you could increase `min.insync.replicas`.\\n\\n    producer, err := sarama.NewSyncProducer(brokerList, config)\\n    if err != nil {\\n        log.Fatalln(\\\"Failed to start Sarama producer:\\\", err)\\n    }\\n\\n    return producer\\n}\\n\\n// Async Producer\\nfunc newAccessLogProducer(brokerList []string) sarama.AsyncProducer {\\n\\n    // For the access log, we are looking for AP semantics, with high throughput.\\n    // By creating batches of compressed messages, we reduce network I/O at a cost of more latency.\\n    config := sarama.NewConfig()\\n    tlsConfig := createTlsConfiguration()\\n    if tlsConfig != nil {\\n        config.Net.TLS.Enable = true\\n        config.Net.TLS.Config = tlsConfig\\n    }\\n    config.Producer.RequiredAcks = sarama.WaitForLocal       // Only wait for the leader to ack\\n    config.Producer.Compression = sarama.CompressionSnappy   // Compress messages\\n    config.Producer.Flush.Frequency = 500 * time.Millisecond // Flush batches every 500ms\\n\\n    producer, err := sarama.NewAsyncProducer(brokerList, config)\\n    if err != nil {\\n        log.Fatalln(\\\"Failed to start Sarama producer:\\\", err)\\n    }\\n\\n    // We will just log to STDOUT if we're not able to produce messages.\\n    // Note: messages will only be returned here after all retry attempts are exhausted.\\n    go func() {\\n        for err := range producer.Errors() {\\n            log.Println(\\\"Failed to write access log entry:\\\", err)\\n        }\\n    }()\\n\\n    return producer\\n}\\n\\ngo func sendMessage(){\\n        // Synch\\n        partition, offset, err := s.DataCollector.SendMessage(&sarama.ProducerMessage{\\n            Topic: \\\"important\\\",\\n            Value: sarama.StringEncoder(r.URL.RawQuery),\\n        })\\n        // Async\\n        s.AccessLogProducer.Input() <- &sarama.ProducerMessage{\\n            Topic: \\\"access_log\\\",\\n            Key:   sarama.StringEncoder(r.RemoteAddr),\\n            Value: entry,\\n        }\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"67abd20c-6607-580b-bb55-74eeb8467444","fields":{"slug":"/producer","title":"Producer"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"consumer\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Consumer\"), mdx(\"ul\", null, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Subscribes to topics and receives message\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Consumer Group -> method of scaling consumption\"), mdx(\"ul\", {\n    \"parentName\": \"li\"\n  }, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Membership triggered by a \", mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"JoinGroup\"), \" call\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"First member is the de-facto group leader\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"leader assigns partitions to consumers in the consumer group\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Membership is maintained by sending \", mdx(\"em\", {\n    \"parentName\": \"li\"\n  }, \"heartbeats\"), \" at intervals regularly to the \", mdx(\"em\", {\n    \"parentName\": \"li\"\n  }, \"group coordinator\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Sent during \", mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"poll\"), \" and \", mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"commit\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"missing heartbeats for a period will trigger rebalance as the consumer is thought to be dead\"))), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, mdx(\"em\", {\n    \"parentName\": \"p\"\n  }, \"Rebalance\"), \" moving partition ownership from one consumer to another\"), mdx(\"ul\", {\n    \"parentName\": \"li\"\n  }, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"high scalability and availability\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"creates a short unavailability window\")))), mdx(\"p\", null), mdx(\"h1\", {\n    \"id\": \"creating-a-consumer\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Creating a Consumer\"), mdx(\"h2\", {\n    \"id\": \"in-rust\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"In [\", mdx(\"a\", {\n    \"href\": \"rust\",\n    \"title\": \"Rust\",\n    \"parentName\": \"h2\"\n  }, \"rust\"), \"]\"), mdx(\"p\", null, \"Crate : \", mdx(\"a\", {\n    \"href\": \"https://crates.io/crates/kafka\",\n    \"parentName\": \"p\"\n  }, \"kafka\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-Rust\",\n    \"parentName\": \"pre\"\n  }, \"use kafka::consumer::{Consumer, FetchOffset, GroupOffsetStorage};\\nlet mut consumer =\\n   Consumer::from_hosts(vec!(\\\"localhost:9092\\\".to_owned()))\\n      .with_topic_partitions(\\\"my-topic\\\".to_owned(), &[0, 1])\\n      .with_fallback_offset(FetchOffset::Earliest)\\n      .with_group(\\\"my-group\\\".to_owned())\\n      .with_offset_storage(GroupOffsetStorage::Kafka)\\n      .create()\\n      .unwrap();\\nloop {\\n  for ms in consumer.poll().unwrap().iter() {\\n    for m in ms.messages() {\\n      println!(\\\"{:?}\\\", m);\\n    }\\n    consumer.consume_messageset(ms);\\n  }\\n  consumer.commit_consumed().unwrap();\\n}\\n\")), mdx(\"p\", null, \"Crate : \", mdx(\"a\", {\n    \"href\": \"https://crates.io/crates/rdkafka\",\n    \"parentName\": \"p\"\n  }, \"rdkafka\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-Rust\",\n    \"parentName\": \"pre\"\n  }, \"async fn consume(brokers: &str, group_id: &str, topics: &[&str]) {\\n    let context = CustomContext;\\n\\n    let consumer: LoggingConsumer = ClientConfig::new()\\n        .set(\\\"group.id\\\", group_id)\\n        .set(\\\"bootstrap.servers\\\", brokers)\\n        .set(\\\"enable.partition.eof\\\", \\\"false\\\")\\n        .set(\\\"session.timeout.ms\\\", \\\"6000\\\")\\n        .set(\\\"enable.auto.commit\\\", \\\"true\\\")\\n        //.set(\\\"statistics.interval.ms\\\", \\\"30000\\\")\\n        //.set(\\\"auto.offset.reset\\\", \\\"smallest\\\")\\n        .set_log_level(RDKafkaLogLevel::Debug)\\n        .create_with_context(context)\\n        .expect(\\\"Consumer creation failed\\\");\\n\\n    consumer\\n        .subscribe(&topics.to_vec())\\n        .expect(\\\"Can't subscribe to specified topics\\\");\\n\\n    // consumer.start() returns a stream. The stream can be used ot chain together expensive steps,\\n    // such as complex computations on a thread pool or asynchronous IO.\\n    let mut message_stream = consumer.start();\\n\\n    while let Some(message) = message_stream.next().await {\\n        match message {\\n            Err(e) => warn!(\\\"Kafka error: {}\\\", e),\\n            Ok(m) => {\\n                let payload = match m.payload_view::<str>() {\\n                    None => \\\"\\\",\\n                    Some(Ok(s)) => s,\\n                    Some(Err(e)) => {\\n                        warn!(\\\"Error while deserializing message payload: {:?}\\\", e);\\n                        \\\"\\\"\\n                    }\\n                };\\n                info!(\\\"key: '{:?}', payload: '{}', topic: {}, partition: {}, offset: {}, timestamp: {:?}\\\",\\n                      m.key(), payload, m.topic(), m.partition(), m.offset(), m.timestamp());\\n                if let Some(headers) = m.headers() {\\n                    for i in 0..headers.count() {\\n                        let header = headers.get(i).unwrap();\\n                        info!(\\\"  Header {:#?}: {:?}\\\", header.0, header.1);\\n                    }\\n                }\\n                consumer.commit_message(&m, CommitMode::Async).unwrap();\\n            }\\n        };\\n    }\\n}\\n\")), mdx(\"hr\", null), mdx(\"h2\", {\n    \"id\": \"in-golang\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"In [\", mdx(\"a\", {\n    \"href\": \"golang\",\n    \"title\": \"Golang\",\n    \"parentName\": \"h2\"\n  }, \"golang\"), \"]\"), mdx(\"p\", null, \"Package : \", mdx(\"a\", {\n    \"href\": \"https://github.com/confluentinc/confluent-kafka-go\",\n    \"parentName\": \"p\"\n  }, \"Confluent Inc\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-golang\",\n    \"parentName\": \"pre\"\n  }, \"func main() {\\n\\n    c, err := kafka.NewConsumer(&kafka.ConfigMap{\\n        \\\"bootstrap.servers\\\": \\\"localhost\\\",\\n        \\\"group.id\\\":          \\\"myGroup\\\",\\n        \\\"auto.offset.reset\\\": \\\"earliest\\\",\\n    })\\n\\n    if err != nil {\\n        panic(err)\\n    }\\n\\n    c.SubscribeTopics([]string{\\\"myTopic\\\", \\\"^aRegex.*[Tt]opic\\\"}, nil)\\n\\n    for {\\n        msg, err := c.ReadMessage(-1)\\n        if err == nil {\\n            fmt.Printf(\\\"Message on %s: %s\\\\n\\\", msg.TopicPartition, string(msg.Value))\\n        } else {\\n            // The client will automatically try to recover from all errors.\\n            fmt.Printf(\\\"Consumer error: %v (%v)\\\\n\\\", err, msg)\\n        }\\n    }\\n\\n    c.Close()\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"package--segmentio\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Package : \", mdx(\"a\", {\n    \"href\": \"https://github.com/segmentio/kafka-go\",\n    \"parentName\": \"h2\"\n  }, \"SegmentIO\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-golang\",\n    \"parentName\": \"pre\"\n  }, \"func consumer(){}\\nr := kafka.NewReader(kafka.ReaderConfig{\\n    Brokers:   []string{\\\"localhost:9092\\\"},\\n    Topic:     \\\"topic-A\\\",\\n    Partition: 0,\\n    MinBytes:  10e3, // 10KB\\n    MaxBytes:  10e6, // 10MB\\n})\\nr.SetOffset(42)\\n\\nfor {\\n    m, err := r.ReadMessage(context.Background())\\n    if err != nil {\\n        break\\n    }\\n    fmt.Printf(\\\"message at offset %d: %s = %s\\\\n\\\", m.Offset, string(m.Key), string(m.Value))\\n}\\n\\nr.Close()\\n}\\n\")), mdx(\"p\", null, \"Package : \", mdx(\"a\", {\n    \"href\": \"https://github.com/Shopify/sarama\",\n    \"parentName\": \"p\"\n  }, \"Sarama\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-golang\",\n    \"parentName\": \"pre\"\n  }, \"// ConsumeClaim must start a consumer loop of ConsumerGroupClaim's Messages().\\nfunc (consumer *Consumer) ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {\\n\\n    // NOTE:\\n    // Do not move the code below to a goroutine.\\n    // The `ConsumeClaim` itself is called within a goroutine, see:\\n    // https://github.com/Shopify/sarama/blob/master/consumer_group.go#L27-L29\\n    for message := range claim.Messages() {\\n        log.Printf(\\\"Message claimed: value = %s, timestamp = %v, topic = %s\\\", string(message.Value), message.Timestamp, message.Topic)\\n        session.MarkMessage(message, \\\"\\\")\\n    }\\n\\n    return nil\\n}\\n\\ngo func() comsumer{\\n        defer wg.Done()\\n        for {\\n            // `Consume` should be called inside an infinite loop, when a\\n            // server-side rebalance happens, the consumer session will need to be\\n            // recreated to get the new claims\\n            if err := client.Consume(ctx, strings.Split(topics, \\\",\\\"), &consumer); err != nil {\\n                log.Panicf(\\\"Error from consumer: %v\\\", err)\\n            }\\n            // check if context was cancelled, signaling that the consumer should stop\\n            if ctx.Err() != nil {\\n                return\\n            }\\n            consumer.ready = make(chan bool)\\n        }\\n    }()\\n\\n\")), mdx(\"h1\", {\n    \"id\": \"commits\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Commits\"), mdx(\"ul\", null, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Consumers use kafka to track their position in each partition\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"commit\"), \" act of updating current position in kafka\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"message \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"__consumer_offsets\"), \" topic with the offset for each partition\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"when rebalance each consumer receives a new partition and obtains the latest committed offset from where to start reading\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Commit Strategy\"), mdx(\"ul\", {\n    \"parentName\": \"li\"\n  }, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Automatic\"), mdx(\"ul\", {\n    \"parentName\": \"li\"\n  }, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Done by consumer every 5 seconds configurable\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Commits largest offset from \", mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"poll\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"call to \", mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"poll\"), \" will always commit the last offset\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"results in double processing if \", mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"rebalance\"), \" occurs in between a 5 sec window\"))), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Commit Current Offset\"), mdx(\"ul\", {\n    \"parentName\": \"li\"\n  }, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Gives control to the developer\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"commitSync\"), \" triggers commit of the last offset returned by \", mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"poll\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"must be called after processing all messages\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Synchronous call blocks the application\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Auto retry till success of non retry-able failure\"))), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Asynchronous Commit\"), mdx(\"ul\", {\n    \"parentName\": \"li\"\n  }, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Fire and forget till we get a callback\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Does not auto retry as a later commit request might have latest Offset\"))), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Async + Sync Commit\"), mdx(\"ul\", {\n    \"parentName\": \"li\"\n  }, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"CommitAsync\"), \" always\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Trigger a CommitSync just before exit\")))))));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"a9f33b82-4aa7-599b-a242-54db28ac76f1","fields":{"slug":"/consumer","title":"Consumer"}}}],"inboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"foam-bubbles\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Foam Bubbles\"), mdx(\"p\", null, \"[\", mdx(\"a\", {\n    \"href\": \"inbox\",\n    \"title\": \"Inbox\",\n    \"parentName\": \"p\"\n  }, \"inbox\"), \"]\"), mdx(\"p\", null, \"[\", mdx(\"a\", {\n    \"href\": \"todo\",\n    \"title\": \"Todo / Reading List\",\n    \"parentName\": \"p\"\n  }, \"todo\"), \"]\"), mdx(\"p\", null, \"[\", mdx(\"a\", {\n    \"href\": \"dwarf\",\n    \"title\": \"Dwarf Debugging Format\",\n    \"parentName\": \"p\"\n  }, \"dwarf\"), \"]\"), mdx(\"p\", null, \"[\", mdx(\"a\", {\n    \"href\": \"kafka\",\n    \"title\": \"Apache Kafka\",\n    \"parentName\": \"p\"\n  }, \"kafka\"), \"]\"), mdx(\"p\", null, \"[\", mdx(\"a\", {\n    \"href\": \"elf\",\n    \"title\": \"elf\",\n    \"parentName\": \"p\"\n  }, \"elf\"), \"]\"), mdx(\"p\", null, \"[\", mdx(\"a\", {\n    \"href\": \"rust\",\n    \"title\": \"Rust\",\n    \"parentName\": \"p\"\n  }, \"rust\"), \"]\"), mdx(\"p\", null, \"[\", mdx(\"a\", {\n    \"href\": \"golang\",\n    \"title\": \"Golang\",\n    \"parentName\": \"p\"\n  }, \"golang\"), \"]\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"0b774b8d-a51d-55d2-8d2d-8f7d194fe0d5","fields":{"slug":"/readme","title":"Foam Bubbles"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"producer\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Producer\"), mdx(\"p\", null, \"Kafka has a binary wire protocol.This means that it is possible for applications to read messages from Kafka or write messages to Kafka simply by sending the correct byte sequences to Kafka\\u2019s network port.\"), mdx(\"p\", null, \"Key Structure is \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"ProducerRecord\")), mdx(\"p\", null), mdx(\"h1\", {\n    \"id\": \"serializer\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Serializer\"), mdx(\"p\", null, \"Converts between wire format and code\"), mdx(\"p\", null, mdx(\"a\", {\n    \"href\": \"https://https://avro.apache.org/docs/current\",\n    \"parentName\": \"p\"\n  }, \"Apache Avro\"), \"\\nDefine a common schema for serialization and deserialization\\nStore in schema Registry\\nStore schema identifier in produced message\\n\"), mdx(\"h1\", {\n    \"id\": \"creating-a-producer\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Creating a Producer\"), mdx(\"h2\", {\n    \"id\": \"in-rust\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"In [\", mdx(\"a\", {\n    \"href\": \"rust\",\n    \"title\": \"Rust\",\n    \"parentName\": \"h2\"\n  }, \"rust\"), \"]\"), mdx(\"p\", null, \"Crate : \", mdx(\"a\", {\n    \"href\": \"https://crates.io/crates/kafka\",\n    \"parentName\": \"p\"\n  }, \"kafka\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-rust\",\n    \"parentName\": \"pre\"\n  }, \"/// Producer Code\\nuse std::fmt::Write;\\nuse std::time::Duration;\\nuse kafka::producer::{Producer, Record, RequiredAcks};\\n\\nlet mut producer = Producer::from_hosts(vec!(\\\"localhost:9092\\\".to_owned()))\\n.with_ack_timeout(Duration::from_secs(1))\\n.with_required_acks(RequiredAcks::One)\\n.create()\\n.unwrap();\\n\\nlet mut buf = String::with*capacity(2);\\nfor i in 0..10 {\\nlet * = write!(&mut buf, \\\"{}\\\", i); // some computation of the message data to be sent\\nproducer.send(&Record::from_value(\\\"my-topic\\\", buf.as_bytes())).unwrap();\\nbuf.clear();\\n}\\n\")), mdx(\"p\", null, \"Crate : \", mdx(\"a\", {\n    \"href\": \"https://crates.io/crates/rdkafka\",\n    \"parentName\": \"p\"\n  }, \"rdkafka\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-Rust\",\n    \"parentName\": \"pre\"\n  }, \" sync fn produce(brokers: &str, topic_name: &str) {\\n    let producer: &FutureProducer = &ClientConfig::new()\\n        .set(\\\"bootstrap.servers\\\", brokers)\\n        .set(\\\"message.timeout.ms\\\", \\\"5000\\\")\\n        .create()\\n        .expect(\\\"Producer creation error\\\");\\n\\n    // This loop is non blocking: all messages will be sent one after the other, without waiting\\n    // for the results.\\n    let futures = (0..5)\\n        .map(|i| async move {\\n            // The send operation on the topic returns a future, which will be\\n            // completed once the result or failure from Kafka is received.\\n            let delivery_status = producer\\n                .send(\\n                    FutureRecord::to(topic_name)\\n                        .payload(&format!(\\\"Message {}\\\", i))\\n                        .key(&format!(\\\"Key {}\\\", i))\\n                        .headers(OwnedHeaders::new().add(\\\"header_key\\\", \\\"header_value\\\")),\\n                    Duration::from_secs(0),\\n                )\\n                .await;\\n\\n            // This will be executed when the result is received.\\n            info!(\\\"Delivery status for message {} received\\\", i);\\n            delivery_status\\n        })\\n        .collect::<Vec<_>>();\\n\\n    // This loop will wait until all delivery statuses have been received.\\n    for future in futures {\\n        info!(\\\"Future completed. Result: {:?}\\\", future.await);\\n    }\\n}\\n\\n\")), mdx(\"p\", null, \"Schema Registry for confluent : \", mdx(\"a\", {\n    \"href\": \"https://github.com/gklijs/schema_registry_converter\",\n    \"parentName\": \"p\"\n  }, \"https://github.com/gklijs/schema_registry_converter\")), mdx(\"p\", null, \"Confluent Write up : \", mdx(\"a\", {\n    \"href\": \"https://www.confluent.io/blog/getting-started-with-rust-and-kafka/\",\n    \"parentName\": \"p\"\n  }, \"https://www.confluent.io/blog/getting-started-with-rust-and-kafka/\")), mdx(\"hr\", null), mdx(\"h2\", {\n    \"id\": \"in-golang\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"In [\", mdx(\"a\", {\n    \"href\": \"golang\",\n    \"title\": \"Golang\",\n    \"parentName\": \"h2\"\n  }, \"golang\"), \"]\"), mdx(\"p\", null, \"Package : \", mdx(\"a\", {\n    \"href\": \"https://github.com/confluentinc/confluent-kafka-go\",\n    \"parentName\": \"p\"\n  }, \"Confluent Inc\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-golang\",\n    \"parentName\": \"pre\"\n  }, \"func main() {\\n\\n    p, err := kafka.NewProducer(&kafka.ConfigMap{\\\"bootstrap.servers\\\": \\\"localhost\\\"})\\n    if err != nil {\\n        panic(err)\\n    }\\n\\n    defer p.Close()\\n\\n    // Delivery report handler for produced messages\\n    go func() {\\n        for e := range p.Events() {\\n            switch ev := e.(type) {\\n            case *kafka.Message:\\n                if ev.TopicPartition.Error != nil {\\n                    fmt.Printf(\\\"Delivery failed: %v\\\\n\\\", ev.TopicPartition)\\n                } else {\\n                    fmt.Printf(\\\"Delivered message to %v\\\\n\\\", ev.TopicPartition)\\n                }\\n            }\\n        }\\n    }()\\n\\n    // Produce messages to topic (asynchronously)\\n    topic := \\\"myTopic\\\"\\n    for _, word := range []string{\\\"Welcome\\\", \\\"to\\\", \\\"the\\\", \\\"Confluent\\\", \\\"Kafka\\\", \\\"Golang\\\", \\\"client\\\"} {\\n        p.Produce(&kafka.Message{\\n            TopicPartition: kafka.TopicPartition{Topic: &topic, Partition: kafka.PartitionAny},\\n            Value:          []byte(word),\\n        }, nil)\\n    }\\n\\n    // Wait for message deliveries before shutting down\\n    p.Flush(15 * 1000)\\n}\\n\")), mdx(\"p\", null, \"Package : \", mdx(\"a\", {\n    \"href\": \"https://github.com/segmentio/kafka-go\",\n    \"parentName\": \"p\"\n  }, \"SegmentIO\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-golang\",\n    \"parentName\": \"pre\"\n  }, \"func producer() {\\n\\n    topic := \\\"my-topic\\\"\\n    partition := 0\\n\\n    conn, _ := kafka.DialLeader(context.Background(), \\\"tcp\\\", \\\"localhost:9092\\\", topic, partition)\\n\\n    conn.SetWriteDeadline(time.Now().Add(10*time.Second))\\n    conn.WriteMessages(\\n    kafka.Message{Value: []byte(\\\"one!\\\")},\\n    kafka.Message{Value: []byte(\\\"two!\\\")},\\n    kafka.Message{Value: []byte(\\\"three!\\\")},\\n    )\\n\\n    conn.Close()\\n}\\n\")), mdx(\"p\", null, \"Package : \", mdx(\"a\", {\n    \"href\": \"https://github.com/Shopify/sarama\",\n    \"parentName\": \"p\"\n  }, \"Sarama\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-golang\",\n    \"parentName\": \"pre\"\n  }, \"//Sync Producer\\nfunc newDataCollector(brokerList []string) sarama.SyncProducer {\\n\\n    // For the data collector, we are looking for strong consistency semantics.\\n    // Because we don't change the flush settings, sarama will try to produce messages\\n    // as fast as possible to keep latency low.\\n    config := sarama.NewConfig()\\n    config.Producer.RequiredAcks = sarama.WaitForAll // Wait for all in-sync replicas to ack the message\\n    config.Producer.Retry.Max = 10                   // Retry up to 10 times to produce the message\\n    config.Producer.Return.Successes = true\\n    tlsConfig := createTlsConfiguration()\\n    if tlsConfig != nil {\\n        config.Net.TLS.Config = tlsConfig\\n        config.Net.TLS.Enable = true\\n    }\\n\\n    // On the broker side, you may want to change the following settings to get\\n    // stronger consistency guarantees:\\n    // - For your broker, set `unclean.leader.election.enable` to false\\n    // - For the topic, you could increase `min.insync.replicas`.\\n\\n    producer, err := sarama.NewSyncProducer(brokerList, config)\\n    if err != nil {\\n        log.Fatalln(\\\"Failed to start Sarama producer:\\\", err)\\n    }\\n\\n    return producer\\n}\\n\\n// Async Producer\\nfunc newAccessLogProducer(brokerList []string) sarama.AsyncProducer {\\n\\n    // For the access log, we are looking for AP semantics, with high throughput.\\n    // By creating batches of compressed messages, we reduce network I/O at a cost of more latency.\\n    config := sarama.NewConfig()\\n    tlsConfig := createTlsConfiguration()\\n    if tlsConfig != nil {\\n        config.Net.TLS.Enable = true\\n        config.Net.TLS.Config = tlsConfig\\n    }\\n    config.Producer.RequiredAcks = sarama.WaitForLocal       // Only wait for the leader to ack\\n    config.Producer.Compression = sarama.CompressionSnappy   // Compress messages\\n    config.Producer.Flush.Frequency = 500 * time.Millisecond // Flush batches every 500ms\\n\\n    producer, err := sarama.NewAsyncProducer(brokerList, config)\\n    if err != nil {\\n        log.Fatalln(\\\"Failed to start Sarama producer:\\\", err)\\n    }\\n\\n    // We will just log to STDOUT if we're not able to produce messages.\\n    // Note: messages will only be returned here after all retry attempts are exhausted.\\n    go func() {\\n        for err := range producer.Errors() {\\n            log.Println(\\\"Failed to write access log entry:\\\", err)\\n        }\\n    }()\\n\\n    return producer\\n}\\n\\ngo func sendMessage(){\\n        // Synch\\n        partition, offset, err := s.DataCollector.SendMessage(&sarama.ProducerMessage{\\n            Topic: \\\"important\\\",\\n            Value: sarama.StringEncoder(r.URL.RawQuery),\\n        })\\n        // Async\\n        s.AccessLogProducer.Input() <- &sarama.ProducerMessage{\\n            Topic: \\\"access_log\\\",\\n            Key:   sarama.StringEncoder(r.RemoteAddr),\\n            Value: entry,\\n        }\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"67abd20c-6607-580b-bb55-74eeb8467444","fields":{"slug":"/producer","title":"Producer"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"gokit\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Gokit\"), mdx(\"p\", null, \"Spring boot like framework for [\", mdx(\"a\", {\n    \"href\": \"golang\",\n    \"title\": \"Golang\",\n    \"parentName\": \"p\"\n  }, \"golang\"), \"]. It has 3 major Components\"), mdx(\"h2\", {\n    \"id\": \"service-layer\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Service Layer\"), mdx(\"ul\", null, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Innermost layer where business logic resides.\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Modeled as services\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Oblivious to Endpoint/Transport Layers\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Can be used by multiple Transports (grpc/json/http)\")), mdx(\"h2\", {\n    \"id\": \"endpoint-layer\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Endpoint Layer\"), mdx(\"ul\", null, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Represents a single RPC Method\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Service exposed as an Endpoint\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Endpoint can be exposed by multiple Transports\")), mdx(\"h2\", {\n    \"id\": \"transport-layer\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Transport Layer\"), mdx(\"ul\", null, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Exposes various Transports\", mdx(\"ul\", {\n    \"parentName\": \"li\"\n  }, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"grpc\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"http\")))), mdx(\"h1\", {\n    \"id\": \"building-a-pastebin-clone\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Building a \", mdx(\"inlineCode\", {\n    \"parentName\": \"h1\"\n  }, \"pastebin\"), \" clone\"), mdx(\"h2\", {\n    \"id\": \"define-a-service-blueprint-interface\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Define a service blueprint interface\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"// PbService provides storage capabilities\\ntype PbService interface {\\n    Create(content string, ctx context.Context) (string, error)\\n    Delete(key string, ctx context.Context) (string, error)\\n    Get(key string, ctx context.Context) (string, error)\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"make-a-new-struct-to-define-the-pastebin-service\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Make a new struct to define the PasteBin Service\"), mdx(\"p\", null, \"This struct is used to group together the functionalities of pastebin service\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"type pbService struct {\\n    memory map[uuid.UUID]string\\n}\\n\\n// NewPbService make a new PbService\\nfunc NewPbService() PbService {\\n    return pbService{\\n        memory: make(map[uuid.UUID]string),\\n    }\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"implement-the-pbservice-interface-on-the-struct\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Implement the PbService Interface on the struct\"), mdx(\"p\", null, \"In [\", mdx(\"a\", {\n    \"href\": \"golang\",\n    \"title\": \"Golang\",\n    \"parentName\": \"p\"\n  }, \"golang\"), \"] we do not have a key word to define that this structs implements a specific interface like the \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"implements\"), \" in Java.\"), mdx(\"p\", null, \"They way we enforce contracts is by implementing all the methods of the contract interface in our case here its the \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"PbService\"), \" interface.\"), mdx(\"p\", null, \"Since our \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"NewPbService\"), \" method returns the type of \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"PbService\"), \" the go compiler will ensure that \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"NewPbService\"), \" confirms to the \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"PbService\"), \" interface.\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"//Create: Here we store the content and return a uuid\\nfunc (s pbService) Create(ctx context.Context, content string) (string, error) {\\n    id := uuid.New()\\n    s.memory[id] = content\\n    return id.String(), nil\\n}\\n\\n//Delete: Here we use the key to find and delete the content stored\\nfunc (s pbService) Delete(ctx context.Context, key string) (string, error) {\\n    id, err := uuid.Parse(key)\\n    if err != nil {\\n        return \\\"\\\", errors.New(\\\"Invalid Uuid Format\\\")\\n    }\\n    delete(s.memory, id)\\n    return \\\"ok\\\", nil\\n}\\n\\n//Get: Here we use the key to find and return the content stored\\nfunc (s pbService) Get(ctx context.Context, key string) (string, error) {\\n    id, err := uuid.Parse(key)\\n    if err != nil {\\n        return \\\"\\\", errors.New(\\\"Invalid Uuid Format\\\")\\n    }\\n    content, exists := s.memory[id]\\n    if exists {\\n        return content, nil\\n    }\\n    return \\\"\\\", errors.New(\\\"Invalid Uuid\\\")\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"request-and-response\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Request and Response\"), mdx(\"p\", null, \"In Go kit, the primary messaging pattern is RPC.\"), mdx(\"p\", null, \"So, every method in our interface will be modeled as a remote procedure call. For each method, we define request and response structs, capturing all of the input and output parameters respectively.\"), mdx(\"h3\", {\n    \"id\": \"create-request-response\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Create Request Response\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"type createPbRequest struct {\\n    content string `json:\\\"content\\\"`\\n}\\n\\ntype createPbResponse struct {\\n    key string `json:\\\"key\\\"`\\n    Err string `json:\\\"err,omitempty\\\"` // errors don't JSON-marshal, so we use a string\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"delete-request-response\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Delete Request Response\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"type deletePbRequest struct {\\n    key string `json:\\\"key\\\"`\\n}\\n\\ntype deletePbResponse struct {\\n    status string `json:\\\"status\\\"`\\n    Err    string `json:\\\"err,omitempty\\\"` // errors don't JSON-marshal, so we use a string\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"get-request-response\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Get Request Response\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"type getPbRequest struct {\\n    key string `json:\\\"key\\\"`\\n}\\n\\ntype getPbResponse struct {\\n    content string `json:\\\"content\\\"`\\n    Err     string `json:\\\"err,omitempty\\\"` // errors don't JSON-marshal, so we use a string\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"define-endpoints\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Define Endpoints\"), mdx(\"p\", null, \"An endpoint represents a single RPC, which is a single method in our service.\"), mdx(\"h3\", {\n    \"id\": \"create-endpoint\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Create Endpoint\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"func createPbEndpoint(svc PbService) endpoint.Endpoint {\\n    return func(ctx context.Context, request interface{}) (interface{}, error) {\\n        req := request.(createPbRequest)\\n        key, err := svc.Create(ctx, req.Content)\\n        if err != nil {\\n            return createPbResponse{key, err.Error()}, nil\\n        }\\n        return createPbResponse{key, \\\"\\\"}, nil\\n    }\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"delete-endpoint\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Delete Endpoint\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"func deletePbEndpoint(svc PbService) endpoint.Endpoint {\\n    return func(ctx context.Context, request interface{}) (interface{}, error) {\\n        req := request.(deletePbRequest)\\n        status, err := svc.Delete(ctx, req.Key)\\n        if err != nil {\\n            return deletePbResponse{status, err.Error()}, nil\\n        }\\n        return deletePbResponse{status, \\\"\\\"}, nil\\n    }\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"get-endpoint\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Get Endpoint\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"func getPbEndpoint(svc PbService) endpoint.Endpoint {\\n    return func(ctx context.Context, request interface{}) (interface{}, error) {\\n        req := request.(getPbRequest)\\n        content, err := svc.Get(ctx, req.Key)\\n        if err != nil {\\n            return getPbResponse{content, err.Error()}, nil\\n        }\\n        return getPbResponse{content, \\\"\\\"}, nil\\n    }\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"define-transport\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Define Transport\"), mdx(\"p\", null, \"Since this trivial example used JSON over HTTP we would have to decode the JSON to structs that our service can understand\"), mdx(\"h3\", {\n    \"id\": \"create-requester-decoder\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Create Requester Decoder\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"func decodeCreatePbRequest(_ context.Context, r *http.Request) (interface{}, error) {\\n    var request createPbRequest\\n    if err := json.NewDecoder(r.Body).Decode(&request); err != nil {\\n        return nil, err\\n    }\\n    return request, nil\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"delete-request-decoder\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Delete Request Decoder\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"func decodeDeletePbRequest(_ context.Context, r *http.Request) (interface{}, error) {\\n    var request deletePbRequest\\n    if err := json.NewDecoder(r.Body).Decode(&request); err != nil {\\n        return nil, err\\n    }\\n    return request, nil\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"get-request-decoder\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Get Request Decoder\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"func decodeGetPbRequest(_ context.Context, r *http.Request) (interface{}, error) {\\n    var request getPbRequest\\n    if err := json.NewDecoder(r.Body).Decode(&request); err != nil {\\n        return nil, err\\n    }\\n    return request, nil\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"response-encoder\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Response Encoder\"), mdx(\"p\", null, \"This method would accept an \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"interface\"), \" type and convert it JSON, this allows it to accept \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"createPbResponse\"), \",\", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"deletePbResponse\"), \",\", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"getPbResponse\"), \" as an \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"interface{}\"), \" and encode it as json using the annotations in the struct definition.\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"func encodeResponse(_ context.Context, w http.ResponseWriter, response interface{}) error {\\n    return json.NewEncoder(w).Encode(response)\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"main\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Main\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"import (\\n    \\\"context\\\"\\n    \\\"encoding/json\\\"\\n    \\\"errors\\\"\\n    \\\"log\\\"\\n    \\\"net/http\\\"\\n\\n    \\\"github.com/go-kit/kit/endpoint\\\"\\n    \\\"github.com/google/uuid\\\"\\n\\n    httptransport \\\"github.com/go-kit/kit/transport/http\\\"\\n)\\n\\nfunc main() {\\n    svc := NewPbService()\\n    createPbHandler := httptransport.NewServer(\\n        createPbEndpoint(svc),\\n        decodeCreatePbRequest,\\n        encodeResponse,\\n    )\\n\\n    deletePbHandler := httptransport.NewServer(\\n        deletePbEndpoint(svc),\\n        decodeDeletePbRequest,\\n        encodeResponse,\\n    )\\n    \\n    getPbHandler := httptransport.NewServer(\\n        getPbEndpoint(svc),\\n        decodeGetPbRequest,\\n        encodeResponse,\\n    )\\n    \\n    http.Handle(\\\"/create\\\", createPbHandler)\\n    http.Handle(\\\"/delete\\\", deletePbHandler)\\n    http.Handle(\\\"/get\\\", getPbHandler)\\n    log.Fatal(http.ListenAndServe(\\\":8080\\\", nil))\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"divide-and-conquer\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Divide and Conquer\"), mdx(\"p\", null, \"At this point the \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"main.go\"), \" has a lot of code so lets move to different files so that we have separation of concerns.\"), mdx(\"h3\", {\n    \"id\": \"servicego\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"inlineCode\", {\n    \"parentName\": \"h3\"\n  }, \"service.go\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"package main\\n\\nimport (\\n    \\\"context\\\"\\n    \\\"errors\\\"\\n\\n    \\\"github.com/google/uuid\\\"\\n)\\n\\n// PbService provides storage capabilities\\ntype PbService interface {\\n    Create(ctx context.Context, content string) (string, error)\\n    Delete(ctx context.Context, key string) (string, error)\\n    Get(ctx context.Context, key string) (string, error)\\n}\\n\\ntype pbService struct {\\n    memory map[uuid.UUID]string\\n}\\n\\n// NewPbService make a new PbService\\nfunc NewPbService() PbService {\\n    return pbService{\\n        memory: make(map[uuid.UUID]string),\\n    }\\n}\\n\\n//Create: Here we store the content and return a uuid\\nfunc (s pbService) Create(ctx context.Context, content string) (string, error) {\\n    id := uuid.New()\\n    s.memory[id] = content\\n    return id.String(), nil\\n}\\n\\n//Get: Here we use the key to find and return the content stored\\nfunc (s pbService) Get(ctx context.Context, key string) (string, error) {\\n    id, err := uuid.Parse(key)\\n    if err != nil {\\n        return \\\"\\\", errors.New(\\\"Invalid Uuid Format\\\")\\n    }\\n    content, exists := s.memory[id]\\n    if exists {\\n        return content, nil\\n    }\\n    return \\\"\\\", errors.New(\\\"Invalid Uuid\\\")\\n}\\n\\n//Delete: Here we use the key to find and delete the content stored\\nfunc (s pbService) Delete(ctx context.Context, key string) (string, error) {\\n    id, err := uuid.Parse(key)\\n    if err != nil {\\n        return \\\"\\\", errors.New(\\\"Invalid Uuid Format\\\")\\n    }\\n    delete(s.memory, id)\\n    return \\\"ok\\\", nil\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"transportgo\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"inlineCode\", {\n    \"parentName\": \"h3\"\n  }, \"transport.go\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"package main\\n\\nimport (\\n    \\\"context\\\"\\n    \\\"encoding/json\\\"\\n    \\\"net/http\\\"\\n\\n    \\\"github.com/go-kit/kit/endpoint\\\"\\n)\\n\\ntype createPbRequest struct {\\n    Content string `json:\\\"content\\\"`\\n}\\n\\ntype createPbResponse struct {\\n    Key string `json:\\\"key\\\"`\\n    Err string `json:\\\"err,omitempty\\\"` // errors don't JSON-marshal, so we use a string\\n}\\n\\ntype getPbRequest struct {\\n    Key string `json:\\\"key\\\"`\\n}\\n\\ntype getPbResponse struct {\\n    Content string `json:\\\"content\\\"`\\n    Err     string `json:\\\"err,omitempty\\\"` // errors don't JSON-marshal, so we use a string\\n}\\n\\ntype deletePbRequest struct {\\n    Key string `json:\\\"key\\\"`\\n}\\n\\ntype deletePbResponse struct {\\n    Status string `json:\\\"status\\\"`\\n    Err    string `json:\\\"err,omitempty\\\"` // errors don't JSON-marshal, so we use a string\\n}\\n\\nfunc createPbEndpoint(svc PbService) endpoint.Endpoint {\\n    return func(ctx context.Context, request interface{}) (interface{}, error) {\\n        req := request.(createPbRequest)\\n        key, err := svc.Create(ctx, req.Content)\\n        if err != nil {\\n            return createPbResponse{key, err.Error()}, nil\\n        }\\n        return createPbResponse{key, \\\"\\\"}, nil\\n    }\\n}\\n\\nfunc deletePbEndpoint(svc PbService) endpoint.Endpoint {\\n    return func(ctx context.Context, request interface{}) (interface{}, error) {\\n        req := request.(deletePbRequest)\\n        status, err := svc.Delete(ctx, req.Key)\\n        if err != nil {\\n            return deletePbResponse{status, err.Error()}, nil\\n        }\\n        return deletePbResponse{status, \\\"\\\"}, nil\\n    }\\n}\\n\\nfunc getPbEndpoint(svc PbService) endpoint.Endpoint {\\n    return func(ctx context.Context, request interface{}) (interface{}, error) {\\n        req := request.(getPbRequest)\\n        content, err := svc.Get(ctx, req.Key)\\n        if err != nil {\\n            return getPbResponse{content, err.Error()}, nil\\n        }\\n        return getPbResponse{content, \\\"\\\"}, nil\\n    }\\n}\\n\\nfunc decodeCreatePbRequest(_ context.Context, r *http.Request) (interface{}, error) {\\n    var request createPbRequest\\n    if err := json.NewDecoder(r.Body).Decode(&request); err != nil {\\n        return nil, err\\n    }\\n    return request, nil\\n}\\n\\nfunc decodeGetPbRequest(_ context.Context, r *http.Request) (interface{}, error) {\\n    var request getPbRequest\\n    if err := json.NewDecoder(r.Body).Decode(&request); err != nil {\\n        return nil, err\\n    }\\n    return request, nil\\n}\\n\\nfunc decodeDeletePbRequest(_ context.Context, r *http.Request) (interface{}, error) {\\n    var request deletePbRequest\\n    if err := json.NewDecoder(r.Body).Decode(&request); err != nil {\\n        return nil, err\\n    }\\n    return request, nil\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"maingo\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"inlineCode\", {\n    \"parentName\": \"h3\"\n  }, \"main.go\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"func main() {\\n    svc := NewPbService()\\n    createPbHandler := httptransport.NewServer(\\n        createPbEndpoint(svc),\\n        decodeCreatePbRequest,\\n        encodeResponse,\\n    )\\n\\n    deletePbHandler := httptransport.NewServer(\\n        deletePbEndpoint(svc),\\n        decodeDeletePbRequest,\\n        encodeResponse,\\n    )\\n    getPbHandler := httptransport.NewServer(\\n        getPbEndpoint(svc),\\n        decodeGetPbRequest,\\n        encodeResponse,\\n    )\\n    http.Handle(\\\"/create\\\", createPbHandler)\\n    http.Handle(\\\"/delete\\\", deletePbHandler)\\n    http.Handle(\\\"/get\\\", getPbHandler)\\n    log.Fatal(http.ListenAndServe(\\\":8080\\\", nil))\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"logging-middleware\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Logging Middleware\"), mdx(\"p\", null, \"All applications need to log information, this can be enabled by adding a logging middleware that we create in a file called \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"logging.go\")), mdx(\"p\", null, \"Middleware in go-kit work on \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"Endpoint\")), mdx(\"p\", null, \"The interface definition is \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"type Middleware func(Endpoint) Endpoint\"), \", which means it is a function that takes in an endpoint and returns an endpoint\"), mdx(\"p\", null, \"We can create the \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"loggingMiddleware\"), \" so that it adheres to the \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"PbService\"), \" by implementing the \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"Create\"), \" \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"Delete\"), \" \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"Get\"), \" methods.\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"type loggingMiddleware struct {\\n    logger log.Logger\\n    next   PbService\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"create\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Create\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"func (m loggingMiddleware) Create(ctx context.Context, content string) (output string, err error) {\\n    // This defered function would be invoked just before the retuen statement\\n    defer func(begin time.Time) {\\n        m.logger.Log(\\n            \\\"method\\\", \\\"CreatePb\\\",\\n            \\\"input\\\", content,\\n            \\\"output\\\", output,\\n            \\\"err\\\", err,\\n            \\\"took\\\", time.Since(begin),\\n        )\\n    }(time.Now())\\n    output, err = m.next.Create(ctx, content)\\n    return\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"delete\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Delete\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \" func (m loggingMiddleware) Delete(ctx context.Context, key string) (output string, err error) {\\n    defer func(begin time.Time) {\\n        m.logger.Log(\\n            \\\"method\\\", \\\"DeletePb\\\",\\n            \\\"input\\\", key,\\n            \\\"output\\\", output,\\n            \\\"err\\\", err,\\n            \\\"took\\\", time.Since(begin),\\n        )\\n    }(time.Now())\\n    output, err = m.next.Delete(ctx, key)\\n    return\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"get\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Get\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"func (m loggingMiddleware) Get(ctx context.Context, key string) (output string, err error) {\\n    defer func(begin time.Time) {\\n        m.logger.Log(\\n            \\\"method\\\", \\\"GetPb\\\",\\n            \\\"input\\\", key,\\n            \\\"output\\\", output,\\n            \\\"err\\\", err,\\n            \\\"took\\\", time.Since(begin),\\n        )\\n    }(time.Now())\\n    output, err = m.next.Get(ctx, key)\\n    return\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"wiring-the-middleware\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Wiring the Middleware\"), mdx(\"p\", null, \"In order to wire the middleware in all we have to do is link it up with the service that we have defined\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-go\",\n    \"parentName\": \"pre\"\n  }, \"package main\\n\\nimport (\\n    \\\"context\\\"\\n    \\\"encoding/json\\\"\\n    \\\"net/http\\\"\\n    \\\"os\\\"\\n\\n    \\\"github.com/go-kit/kit/log\\\"\\n\\n    httptransport \\\"github.com/go-kit/kit/transport/http\\\"\\n)\\n\\nfunc main() {\\n    // Use the global logger\\n    logger := log.NewLogfmtLogger(os.Stderr)\\n    var svc PbService\\n    svc = NewPbService()\\n    // Wire the middleware and thats it\\n    svc = loggingMiddleware{logger, svc}\\n\\n    createPbHandler := httptransport.NewServer(\\n        createPbEndpoint(svc),\\n        decodeCreatePbRequest,\\n        encodeResponse,\\n    )\\n\\n    deletePbHandler := httptransport.NewServer(\\n        deletePbEndpoint(svc),\\n        decodeDeletePbRequest,\\n        encodeResponse,\\n    )\\n\\n    getPbHandler := httptransport.NewServer(\\n        getPbEndpoint(svc),\\n        decodeGetPbRequest,\\n        encodeResponse,\\n    )\\n    http.Handle(\\\"/create\\\", createPbHandler)\\n    http.Handle(\\\"/delete\\\", deletePbHandler)\\n    http.Handle(\\\"/get\\\", getPbHandler)\\n    logger.Log(\\\"msg\\\", \\\"HTTP\\\", \\\"addr\\\", \\\":8080\\\")\\n    logger.Log(\\\"err\\\", http.ListenAndServe(\\\":8080\\\", nil))\\n}\\n\\nfunc encodeResponse(_ context.Context, w http.ResponseWriter, response interface{}) error {\\n    return json.NewEncoder(w).Encode(response)\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"pastebin\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"PasteBin\"), mdx(\"h3\", {\n    \"id\": \"client\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Client\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-sh\",\n    \"parentName\": \"pre\"\n  }, \"\\n$ curl localhost:8080/create -XPOST -d '{\\\"content\\\":\\\"THIS IS SPARTA\\\"}'\\n\\n{\\\"key\\\":\\\"c449250a-d74c-4d23-acbb-6785b0bd822a\\\"} \\n\\n$ curl localhost:8080/get -XPOST -d '{\\\"key\\\":\\\"c449250a-d74c-4d23-acbb-6785b0bd822a\\\"}'\\n\\n{\\\"content\\\":\\\"THIS IS SPARTA\\\"}\\n\\n$ curl localhost:8I00/delete -XPOST -d '{\\\"key\\\":\\\"c449250a-d74c-4d23-acbb-6785b0bd822a\\\"}'\\n\\n{\\\"status\\\":\\\"ok\\\"}\\n\\n$ curl localhost:8080/get -XPOST -d '{\\\"key\\\":\\\"c449250a-d74c-4d23-acbb-6785b0bd822a\\\"}'\\n\\n{\\\"content\\\":\\\"\\\",\\\"err\\\":\\\"Invalid Uuid\\\"}\\n\\n\")), mdx(\"h3\", {\n    \"id\": \"server\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Server\"), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-sh\",\n    \"parentName\": \"pre\"\n  }, \"$ ./pastebin-II \\n\\nmsg=HTTP addr=:8080\\n\\nmethod=CreatePb input=\\\"THIS IS SPARTA\\\" output=c449250a-d74c-4d23-acbb-6785b0bd822a err=null took=67.92\\xB5s\\n\\nmethod=GetPb input=c449250a-d74c-4d23-acbb-6785b0bd822a output=\\\"THIS IS SPARTA\\\" err=null took=1.675\\xB5s\\n\\nmethod=DeletePb input=c449250a-d74c-4d23-acbb-6785b0bd822a output=ok err=null took=1.45\\xB5s\\n\\nmethod=GetPb input=c449250a-d74c-4d23-acbb-6785b0bd822a output= err=\\\"Invalid Uuid\\\" took=803ns\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"7afde6b3-d4de-54bb-8c90-665201f30ec2","fields":{"slug":"/gokit","title":"Gokit"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"consumer\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Consumer\"), mdx(\"ul\", null, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Subscribes to topics and receives message\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Consumer Group -> method of scaling consumption\"), mdx(\"ul\", {\n    \"parentName\": \"li\"\n  }, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Membership triggered by a \", mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"JoinGroup\"), \" call\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"First member is the de-facto group leader\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"leader assigns partitions to consumers in the consumer group\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Membership is maintained by sending \", mdx(\"em\", {\n    \"parentName\": \"li\"\n  }, \"heartbeats\"), \" at intervals regularly to the \", mdx(\"em\", {\n    \"parentName\": \"li\"\n  }, \"group coordinator\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Sent during \", mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"poll\"), \" and \", mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"commit\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"missing heartbeats for a period will trigger rebalance as the consumer is thought to be dead\"))), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, mdx(\"em\", {\n    \"parentName\": \"p\"\n  }, \"Rebalance\"), \" moving partition ownership from one consumer to another\"), mdx(\"ul\", {\n    \"parentName\": \"li\"\n  }, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"high scalability and availability\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"creates a short unavailability window\")))), mdx(\"p\", null), mdx(\"h1\", {\n    \"id\": \"creating-a-consumer\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Creating a Consumer\"), mdx(\"h2\", {\n    \"id\": \"in-rust\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"In [\", mdx(\"a\", {\n    \"href\": \"rust\",\n    \"title\": \"Rust\",\n    \"parentName\": \"h2\"\n  }, \"rust\"), \"]\"), mdx(\"p\", null, \"Crate : \", mdx(\"a\", {\n    \"href\": \"https://crates.io/crates/kafka\",\n    \"parentName\": \"p\"\n  }, \"kafka\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-Rust\",\n    \"parentName\": \"pre\"\n  }, \"use kafka::consumer::{Consumer, FetchOffset, GroupOffsetStorage};\\nlet mut consumer =\\n   Consumer::from_hosts(vec!(\\\"localhost:9092\\\".to_owned()))\\n      .with_topic_partitions(\\\"my-topic\\\".to_owned(), &[0, 1])\\n      .with_fallback_offset(FetchOffset::Earliest)\\n      .with_group(\\\"my-group\\\".to_owned())\\n      .with_offset_storage(GroupOffsetStorage::Kafka)\\n      .create()\\n      .unwrap();\\nloop {\\n  for ms in consumer.poll().unwrap().iter() {\\n    for m in ms.messages() {\\n      println!(\\\"{:?}\\\", m);\\n    }\\n    consumer.consume_messageset(ms);\\n  }\\n  consumer.commit_consumed().unwrap();\\n}\\n\")), mdx(\"p\", null, \"Crate : \", mdx(\"a\", {\n    \"href\": \"https://crates.io/crates/rdkafka\",\n    \"parentName\": \"p\"\n  }, \"rdkafka\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-Rust\",\n    \"parentName\": \"pre\"\n  }, \"async fn consume(brokers: &str, group_id: &str, topics: &[&str]) {\\n    let context = CustomContext;\\n\\n    let consumer: LoggingConsumer = ClientConfig::new()\\n        .set(\\\"group.id\\\", group_id)\\n        .set(\\\"bootstrap.servers\\\", brokers)\\n        .set(\\\"enable.partition.eof\\\", \\\"false\\\")\\n        .set(\\\"session.timeout.ms\\\", \\\"6000\\\")\\n        .set(\\\"enable.auto.commit\\\", \\\"true\\\")\\n        //.set(\\\"statistics.interval.ms\\\", \\\"30000\\\")\\n        //.set(\\\"auto.offset.reset\\\", \\\"smallest\\\")\\n        .set_log_level(RDKafkaLogLevel::Debug)\\n        .create_with_context(context)\\n        .expect(\\\"Consumer creation failed\\\");\\n\\n    consumer\\n        .subscribe(&topics.to_vec())\\n        .expect(\\\"Can't subscribe to specified topics\\\");\\n\\n    // consumer.start() returns a stream. The stream can be used ot chain together expensive steps,\\n    // such as complex computations on a thread pool or asynchronous IO.\\n    let mut message_stream = consumer.start();\\n\\n    while let Some(message) = message_stream.next().await {\\n        match message {\\n            Err(e) => warn!(\\\"Kafka error: {}\\\", e),\\n            Ok(m) => {\\n                let payload = match m.payload_view::<str>() {\\n                    None => \\\"\\\",\\n                    Some(Ok(s)) => s,\\n                    Some(Err(e)) => {\\n                        warn!(\\\"Error while deserializing message payload: {:?}\\\", e);\\n                        \\\"\\\"\\n                    }\\n                };\\n                info!(\\\"key: '{:?}', payload: '{}', topic: {}, partition: {}, offset: {}, timestamp: {:?}\\\",\\n                      m.key(), payload, m.topic(), m.partition(), m.offset(), m.timestamp());\\n                if let Some(headers) = m.headers() {\\n                    for i in 0..headers.count() {\\n                        let header = headers.get(i).unwrap();\\n                        info!(\\\"  Header {:#?}: {:?}\\\", header.0, header.1);\\n                    }\\n                }\\n                consumer.commit_message(&m, CommitMode::Async).unwrap();\\n            }\\n        };\\n    }\\n}\\n\")), mdx(\"hr\", null), mdx(\"h2\", {\n    \"id\": \"in-golang\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"In [\", mdx(\"a\", {\n    \"href\": \"golang\",\n    \"title\": \"Golang\",\n    \"parentName\": \"h2\"\n  }, \"golang\"), \"]\"), mdx(\"p\", null, \"Package : \", mdx(\"a\", {\n    \"href\": \"https://github.com/confluentinc/confluent-kafka-go\",\n    \"parentName\": \"p\"\n  }, \"Confluent Inc\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-golang\",\n    \"parentName\": \"pre\"\n  }, \"func main() {\\n\\n    c, err := kafka.NewConsumer(&kafka.ConfigMap{\\n        \\\"bootstrap.servers\\\": \\\"localhost\\\",\\n        \\\"group.id\\\":          \\\"myGroup\\\",\\n        \\\"auto.offset.reset\\\": \\\"earliest\\\",\\n    })\\n\\n    if err != nil {\\n        panic(err)\\n    }\\n\\n    c.SubscribeTopics([]string{\\\"myTopic\\\", \\\"^aRegex.*[Tt]opic\\\"}, nil)\\n\\n    for {\\n        msg, err := c.ReadMessage(-1)\\n        if err == nil {\\n            fmt.Printf(\\\"Message on %s: %s\\\\n\\\", msg.TopicPartition, string(msg.Value))\\n        } else {\\n            // The client will automatically try to recover from all errors.\\n            fmt.Printf(\\\"Consumer error: %v (%v)\\\\n\\\", err, msg)\\n        }\\n    }\\n\\n    c.Close()\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"package--segmentio\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Package : \", mdx(\"a\", {\n    \"href\": \"https://github.com/segmentio/kafka-go\",\n    \"parentName\": \"h2\"\n  }, \"SegmentIO\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-golang\",\n    \"parentName\": \"pre\"\n  }, \"func consumer(){}\\nr := kafka.NewReader(kafka.ReaderConfig{\\n    Brokers:   []string{\\\"localhost:9092\\\"},\\n    Topic:     \\\"topic-A\\\",\\n    Partition: 0,\\n    MinBytes:  10e3, // 10KB\\n    MaxBytes:  10e6, // 10MB\\n})\\nr.SetOffset(42)\\n\\nfor {\\n    m, err := r.ReadMessage(context.Background())\\n    if err != nil {\\n        break\\n    }\\n    fmt.Printf(\\\"message at offset %d: %s = %s\\\\n\\\", m.Offset, string(m.Key), string(m.Value))\\n}\\n\\nr.Close()\\n}\\n\")), mdx(\"p\", null, \"Package : \", mdx(\"a\", {\n    \"href\": \"https://github.com/Shopify/sarama\",\n    \"parentName\": \"p\"\n  }, \"Sarama\")), mdx(\"pre\", null, mdx(\"code\", {\n    \"className\": \"language-golang\",\n    \"parentName\": \"pre\"\n  }, \"// ConsumeClaim must start a consumer loop of ConsumerGroupClaim's Messages().\\nfunc (consumer *Consumer) ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {\\n\\n    // NOTE:\\n    // Do not move the code below to a goroutine.\\n    // The `ConsumeClaim` itself is called within a goroutine, see:\\n    // https://github.com/Shopify/sarama/blob/master/consumer_group.go#L27-L29\\n    for message := range claim.Messages() {\\n        log.Printf(\\\"Message claimed: value = %s, timestamp = %v, topic = %s\\\", string(message.Value), message.Timestamp, message.Topic)\\n        session.MarkMessage(message, \\\"\\\")\\n    }\\n\\n    return nil\\n}\\n\\ngo func() comsumer{\\n        defer wg.Done()\\n        for {\\n            // `Consume` should be called inside an infinite loop, when a\\n            // server-side rebalance happens, the consumer session will need to be\\n            // recreated to get the new claims\\n            if err := client.Consume(ctx, strings.Split(topics, \\\",\\\"), &consumer); err != nil {\\n                log.Panicf(\\\"Error from consumer: %v\\\", err)\\n            }\\n            // check if context was cancelled, signaling that the consumer should stop\\n            if ctx.Err() != nil {\\n                return\\n            }\\n            consumer.ready = make(chan bool)\\n        }\\n    }()\\n\\n\")), mdx(\"h1\", {\n    \"id\": \"commits\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Commits\"), mdx(\"ul\", null, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Consumers use kafka to track their position in each partition\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"commit\"), \" act of updating current position in kafka\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"message \", mdx(\"inlineCode\", {\n    \"parentName\": \"p\"\n  }, \"__consumer_offsets\"), \" topic with the offset for each partition\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"when rebalance each consumer receives a new partition and obtains the latest committed offset from where to start reading\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Commit Strategy\"), mdx(\"ul\", {\n    \"parentName\": \"li\"\n  }, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Automatic\"), mdx(\"ul\", {\n    \"parentName\": \"li\"\n  }, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Done by consumer every 5 seconds configurable\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Commits largest offset from \", mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"poll\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"call to \", mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"poll\"), \" will always commit the last offset\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"results in double processing if \", mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"rebalance\"), \" occurs in between a 5 sec window\"))), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Commit Current Offset\"), mdx(\"ul\", {\n    \"parentName\": \"li\"\n  }, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Gives control to the developer\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"commitSync\"), \" triggers commit of the last offset returned by \", mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"poll\")), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"must be called after processing all messages\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Synchronous call blocks the application\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Auto retry till success of non retry-able failure\"))), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Asynchronous Commit\"), mdx(\"ul\", {\n    \"parentName\": \"li\"\n  }, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Fire and forget till we get a callback\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Does not auto retry as a later commit request might have latest Offset\"))), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"p\", {\n    \"parentName\": \"li\"\n  }, \"Async + Sync Commit\"), mdx(\"ul\", {\n    \"parentName\": \"li\"\n  }, mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, mdx(\"inlineCode\", {\n    \"parentName\": \"li\"\n  }, \"CommitAsync\"), \" always\"), mdx(\"li\", {\n    \"parentName\": \"ul\"\n  }, \"Trigger a CommitSync just before exit\")))))));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"a9f33b82-4aa7-599b-a242-54db28ac76f1","fields":{"slug":"/consumer","title":"Consumer"}}}]},"fields":{"slug":"/golang","title":"Golang"}}},"pageContext":{"id":"c67dd331-477d-55b4-b7e1-c14bf357a00a"}},"staticQueryHashes":["2098632890","426988268"]}