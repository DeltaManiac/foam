<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/foam/styles.2e98cd11f42589b7a982.css">.popover{position:relative;max-width:16rem;box-shadow:0 10px 15px -3px var(--shadow),0 4px 6px -2px rgba(0,0,0,.05);padding:1rem;border:1px solid var(--separator);border-radius:.5rem;background-color:var(--references-bg);max-height:16rem;overflow:hidden}.popover.no-max-width{max-width:90vw}.popover.with-markdown{font-size:.875rem}.popover h1{margin:0;padding:0;font-size:1rem}.popover ul{padding-left:1rem}.popover .more-content-blind{height:4rem;position:absolute;background:transparent;background:linear-gradient(0,var(--references-bg),var(--references-bg-80) 50%,var(--references-bg-0));top:12rem;width:100%;left:0}.tippy-box[data-animation=shift-away][data-state=hidden]{opacity:0}.tippy-box[data-animation=shift-away][data-state=hidden][data-placement^=top]{transform:translateY(10px)}.tippy-box[data-animation=shift-away][data-state=hidden][data-placement^=bottom]{transform:translateY(-10px)}.tippy-box[data-animation=shift-away][data-state=hidden][data-placement^=left]{transform:translateX(10px)}.tippy-box[data-animation=shift-away][data-state=hidden][data-placement^=right]{transform:translateX(-10px)}.reference{text-decoration:none}.reference:hover{color:var(--references-highlight)}.reference>div{padding-top:.5rem;padding-bottom:.5rem}.reference>div>p{margin:0;font-size:.875rem}.reference>div>ul{margin:0}.references-block{color:var(--references-text);padding:1rem;margin:1rem 0;border-radius:.5rem;background-color:var(--references-bg);transition:background-color .3s ease,color .3s ease}.references-block>div{margin-bottom:1rem}.references-block>hr{margin-left:auto;margin-right:auto;width:8rem}.references-block a{color:var(--references-text);transition:color .3s ease}.references-block>p:last-child{margin-bottom:0}.note-container{background:var(--note-bg);transition:background .3s ease}.note-container:first-child{border-left:none}.note-container .note-content,.note-container .obstructed-label{transition:opacity 75ms linear}.note-container .obstructed-label{display:block;color:var(--text);text-decoration:none;font-size:17px;line-height:40px;font-weight:500;-ms-writing-mode:tb-lr;writing-mode:vertical-lr;margin-top:36px;top:0;bottom:0;left:0;position:absolute;background-color:transparent;width:40px;overflow:hidden;opacity:0;transition:color .3s ease;pointer-events:none}.note-container.note-container-highlighted{background:var(--references-bg);transition:background .3s ease}.note-content img{max-width:100%}@media screen and (max-width:800px){.note-container{padding:16px;width:100%;overflow-y:auto}}@media screen and (min-width:801px){.note-container{transition:box-shadow .1s linear,opacity 75ms linear,transform .2s cubic-bezier(.19,1,.22,1);flex-shrink:0;width:625px;max-width:625px;top:0;position:-webkit-sticky;position:sticky;flex-grow:1;border-left:1px solid var(--separator);padding:0}.note-content{overflow-y:auto;height:100%;padding:32px}.note-container-overlay{box-shadow:0 0 15px 3px var(--shadow)}.note-container-obstructed .note-content{opacity:0}.note-container-obstructed .obstructed-label{opacity:1;pointer-events:all}}.dark-mode-toggle{cursor:pointer;transform:scale(.6)}.dark-mode-toggle input{display:none}.dark-mode-toggle input+div{border-radius:50%;width:36px;height:36px;position:relative;box-shadow:inset 16px -16px 0 0 #fff;transform:scale(1) rotate(-2deg);transition:box-shadow .5s ease 0s,transform .4s ease .1s}.dark-mode-toggle input+div:before{content:"";width:inherit;height:inherit;border-radius:inherit;position:absolute;left:0;top:0;transition:background .3s ease}.dark-mode-toggle input+div:after{content:"";width:8px;height:8px;border-radius:50%;margin:-4px 0 0 -4px;position:absolute;top:50%;left:50%;box-shadow:0 -23px 0 var(--link),0 23px 0 var(--link),23px 0 0 var(--link),-23px 0 0 var(--link),15px 15px 0 var(--link),-15px 15px 0 var(--link),15px -15px 0 var(--link),-15px -15px 0 var(--link);transform:scale(0);transition:all .3s ease}.dark-mode-toggle input:checked+div{box-shadow:inset 32px -32px 0 0 #fff;transform:scale(.5) rotate(0deg);transition:transform .3s ease .1s,box-shadow .2s ease 0s}.dark-mode-toggle input:checked+:before{background:var(--link);transition:background .3s ease .1s}.dark-mode-toggle input:checked+:after{transform:scale(1.5);transition:transform .5s ease .15s}.graph-button{border:0;background:none;cursor:pointer}.graph-button svg g{stroke:var(--link)}header{width:100%;min-height:57px;z-index:5;background-color:var(--note-bg);border-bottom:1px solid var(--separator);display:flex;justify-content:space-between;align-items:center;padding:10px 32px;flex-wrap:wrap;transition:background-color .3s ease}header>a{font-weight:700;color:var(--text);text-decoration:none;transition:color .3s ease}header .controls{display:flex}html{font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;line-height:1.5}body.light-mode{--main-bg:#fafafc;--note-bg:#fff;--text:#1a202c;--separator:#e2e8f0;--shadow:rgba(0,0,0,0.1);--link:#3182ce;--references-bg:#ebf4ff;--references-bg-80:rgba(235,244,255,0.8);--references-bg-0:rgba(235,244,255,0);--references-text:#718096;--references-highlight:#4a5568}body.dark-mode{--main-bg:#000;--note-bg:#0a0d11;--text:#fafafc;--separator:#252525;--shadow:hsla(0,0%,100%,0.1);--link:#3da1ff;--references-bg:#17181a;--references-bg-80:rgba(23,24,26,0.8);--references-bg-0:rgba(23,24,26,0);--references-text:#8c9fbb;--references-highlight:#b3cbf0}body{background-color:var(--main-bg);color:var(--text);margin:0;padding:0;height:100vh;transition:background-color .3s ease,color .3s ease}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,p,pre{margin:0}*,:after,:before{box-sizing:border-box}h1,h2,h3{font-weight:700}hr{margin-top:1rem;margin-bottom:1rem;border:solid var(--separator);border-width:1px 0 0;box-sizing:content-box;height:0;overflow:visible}a{color:var(--link);text-decoration:underline;transition:color .3s ease}a:hover{text-decoration:none}h1{font-size:1.875rem;margin-top:1rem}h1,p{margin-bottom:1rem}.layout{height:100vh;display:flex;flex-direction:column}.note-columns-scrolling-container{display:flex;overflow-x:auto;overflow-y:hidden;flex-grow:1}.note-columns-container{display:flex;flex-grow:1;transition:width .1s cubic-bezier(.19,1,.22,1)}@media screen and (max-width:800px){.note-columns-container{width:unset!important}}.overlay{z-index:98;position:fixed;top:0;right:0;bottom:0;left:0;display:flex;align-items:center;justify-content:center;height:100%;width:100%;background-color:var(--shadow);-webkit-backdrop-filter:blur(4px);backdrop-filter:blur(4px)}.modal{z-index:99;position:fixed;border-radius:8px;background-color:var(--main-bg);box-shadow:-5px -5px 15px -3px var(--shadow),0 4px 6px -2px rgba(0,0,0,.05)}.modal-close,.modal-scale{position:absolute;top:0;right:0;padding:5px;border:0;background:none;color:var(--text);cursor:pointer}.modal-close svg,.modal-scale svg{width:20px;height:20px}.modal-close path,.modal-scale path{fill:currentColor}.modal-scale{right:30px}.modal-minimized .modal-close svg,.modal-minimized .modal-scale svg{width:15px;height:15px}.modal-minimized .modal-scale{right:25px}.modal-body{height:100%;width:100%}.modal-body .node,.modal-body .text{cursor:pointer}</style><meta name="generator" content="Gatsby 2.24.37"/><link as="script" rel="preload" href="/foam/component---node-modules-gatsby-theme-garden-src-templates-local-file-js-5e093f5807d6eb5ecced.js"/><link as="script" rel="preload" href="/foam/styles-89fd2ae28bdf06750a71.js"/><link as="script" rel="preload" href="/foam/app-a23c3f4de5f92c6458ad.js"/><link as="script" rel="preload" href="/foam/framework-8c8d363c63d1a9a80d21.js"/><link as="script" rel="preload" href="/foam/webpack-runtime-23d80780450712e11cfe.js"/><link as="fetch" rel="preload" href="/foam/page-data/gokit/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/foam/page-data/sq/d/2098632890.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/foam/page-data/sq/d/426988268.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/foam/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="layout"><header><a href="/foam/"><h3>Foam</h3></a><div class="controls"><button title="Show Graph visualisation" aria-label="Show Graph visualisation" class="graph-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="20" height="20"><g fill="none" stroke-width="2"><circle cx="11.733" cy="3.181" r="1.902"></circle><circle cx="16.864" cy="10.861" r="1.902"></circle><circle cx="7.47" cy="16.822" r="1.902"></circle><circle cx="3.046" cy="6.275" r="1.902"></circle><circle cx="9.372" cy="10.861" r="1.902"></circle><line x1="11.635" x2="14.655" y1="10.861" y2="10.861"></line><line x1="10" x2="10.895" y1="8.959" y2="5.573"></line><line x1="7.47" x2="4.5" y1="9.68" y2="7.5"></line><line x1="8.25" x2="8.809" y1="14.92" y2="13.088"></line></g></svg></button><label class="dark-mode-toggle" aria-label="Activate dark mode" title="Activate dark mode"><input type="checkbox" checked=""/><div></div></label></div></header><div class="note-columns-scrolling-container"><div class="note-columns-container" style="width:1250px"><div class="note-container   " style="left:0;right:-585px"><div class="note-content"><h1 id="gokit" style="position:relative">Gokit</h1><p>Spring boot like framework for [<a href="golang" title="Golang">golang</a>]. It has 3 major Components</p><h2 id="service-layer" style="position:relative">Service Layer</h2><ul><li>Innermost layer where business logic resides.</li><li>Modeled as services</li><li>Oblivious to Endpoint/Transport Layers</li><li>Can be used by multiple Transports (grpc/json/http)</li></ul><h2 id="endpoint-layer" style="position:relative">Endpoint Layer</h2><ul><li>Represents a single RPC Method</li><li>Service exposed as an Endpoint</li><li>Endpoint can be exposed by multiple Transports</li></ul><h2 id="transport-layer" style="position:relative">Transport Layer</h2><ul><li>Exposes various Transports<ul><li>grpc</li><li>http</li></ul></li></ul><h1 id="building-a-pastebin-clone" style="position:relative">Building a <code>pastebin</code> clone</h1><h2 id="define-a-service-blueprint-interface" style="position:relative">Define a service blueprint interface</h2><pre><code class="language-go">// PbService provides storage capabilities
type PbService interface {
    Create(content string, ctx context.Context) (string, error)
    Delete(key string, ctx context.Context) (string, error)
    Get(key string, ctx context.Context) (string, error)
}
</code></pre><h2 id="make-a-new-struct-to-define-the-pastebin-service" style="position:relative">Make a new struct to define the PasteBin Service</h2><p>This struct is used to group together the functionalities of pastebin service</p><pre><code class="language-go">type pbService struct {
    memory map[uuid.UUID]string
}

// NewPbService make a new PbService
func NewPbService() PbService {
    return pbService{
        memory: make(map[uuid.UUID]string),
    }
}
</code></pre><h2 id="implement-the-pbservice-interface-on-the-struct" style="position:relative">Implement the PbService Interface on the struct</h2><p>In [<a href="golang" title="Golang">golang</a>] we do not have a key word to define that this structs implements a specific interface like the <code>implements</code> in Java.</p><p>They way we enforce contracts is by implementing all the methods of the contract interface in our case here its the <code>PbService</code> interface.</p><p>Since our <code>NewPbService</code> method returns the type of <code>PbService</code> the go compiler will ensure that <code>NewPbService</code> confirms to the <code>PbService</code> interface.</p><pre><code class="language-go">//Create: Here we store the content and return a uuid
func (s pbService) Create(ctx context.Context, content string) (string, error) {
    id := uuid.New()
    s.memory[id] = content
    return id.String(), nil
}

//Delete: Here we use the key to find and delete the content stored
func (s pbService) Delete(ctx context.Context, key string) (string, error) {
    id, err := uuid.Parse(key)
    if err != nil {
        return &quot;&quot;, errors.New(&quot;Invalid Uuid Format&quot;)
    }
    delete(s.memory, id)
    return &quot;ok&quot;, nil
}

//Get: Here we use the key to find and return the content stored
func (s pbService) Get(ctx context.Context, key string) (string, error) {
    id, err := uuid.Parse(key)
    if err != nil {
        return &quot;&quot;, errors.New(&quot;Invalid Uuid Format&quot;)
    }
    content, exists := s.memory[id]
    if exists {
        return content, nil
    }
    return &quot;&quot;, errors.New(&quot;Invalid Uuid&quot;)
}
</code></pre><h2 id="request-and-response" style="position:relative">Request and Response</h2><p>In Go kit, the primary messaging pattern is RPC.</p><p>So, every method in our interface will be modeled as a remote procedure call. For each method, we define request and response structs, capturing all of the input and output parameters respectively.</p><h3 id="create-request-response" style="position:relative">Create Request Response</h3><pre><code class="language-go">type createPbRequest struct {
    content string `json:&quot;content&quot;`
}

type createPbResponse struct {
    key string `json:&quot;key&quot;`
    Err string `json:&quot;err,omitempty&quot;` // errors don&#x27;t JSON-marshal, so we use a string
}
</code></pre><h3 id="delete-request-response" style="position:relative">Delete Request Response</h3><pre><code class="language-go">type deletePbRequest struct {
    key string `json:&quot;key&quot;`
}

type deletePbResponse struct {
    status string `json:&quot;status&quot;`
    Err    string `json:&quot;err,omitempty&quot;` // errors don&#x27;t JSON-marshal, so we use a string
}
</code></pre><h3 id="get-request-response" style="position:relative">Get Request Response</h3><pre><code class="language-go">type getPbRequest struct {
    key string `json:&quot;key&quot;`
}

type getPbResponse struct {
    content string `json:&quot;content&quot;`
    Err     string `json:&quot;err,omitempty&quot;` // errors don&#x27;t JSON-marshal, so we use a string
}
</code></pre><h2 id="define-endpoints" style="position:relative">Define Endpoints</h2><p>An endpoint represents a single RPC, which is a single method in our service.</p><h3 id="create-endpoint" style="position:relative">Create Endpoint</h3><pre><code class="language-go">func createPbEndpoint(svc PbService) endpoint.Endpoint {
    return func(ctx context.Context, request interface{}) (interface{}, error) {
        req := request.(createPbRequest)
        key, err := svc.Create(ctx, req.Content)
        if err != nil {
            return createPbResponse{key, err.Error()}, nil
        }
        return createPbResponse{key, &quot;&quot;}, nil
    }
}
</code></pre><h3 id="delete-endpoint" style="position:relative">Delete Endpoint</h3><pre><code class="language-go">func deletePbEndpoint(svc PbService) endpoint.Endpoint {
    return func(ctx context.Context, request interface{}) (interface{}, error) {
        req := request.(deletePbRequest)
        status, err := svc.Delete(ctx, req.Key)
        if err != nil {
            return deletePbResponse{status, err.Error()}, nil
        }
        return deletePbResponse{status, &quot;&quot;}, nil
    }
}
</code></pre><h3 id="get-endpoint" style="position:relative">Get Endpoint</h3><pre><code class="language-go">func getPbEndpoint(svc PbService) endpoint.Endpoint {
    return func(ctx context.Context, request interface{}) (interface{}, error) {
        req := request.(getPbRequest)
        content, err := svc.Get(ctx, req.Key)
        if err != nil {
            return getPbResponse{content, err.Error()}, nil
        }
        return getPbResponse{content, &quot;&quot;}, nil
    }
}
</code></pre><h2 id="define-transport" style="position:relative">Define Transport</h2><p>Since this trivial example used JSON over HTTP we would have to decode the JSON to structs that our service can understand</p><h3 id="create-requester-decoder" style="position:relative">Create Requester Decoder</h3><pre><code class="language-go">func decodeCreatePbRequest(_ context.Context, r *http.Request) (interface{}, error) {
    var request createPbRequest
    if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil {
        return nil, err
    }
    return request, nil
}
</code></pre><h3 id="delete-request-decoder" style="position:relative">Delete Request Decoder</h3><pre><code class="language-go">func decodeDeletePbRequest(_ context.Context, r *http.Request) (interface{}, error) {
    var request deletePbRequest
    if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil {
        return nil, err
    }
    return request, nil
}
</code></pre><h3 id="get-request-decoder" style="position:relative">Get Request Decoder</h3><pre><code class="language-go">func decodeGetPbRequest(_ context.Context, r *http.Request) (interface{}, error) {
    var request getPbRequest
    if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil {
        return nil, err
    }
    return request, nil
}
</code></pre><h3 id="response-encoder" style="position:relative">Response Encoder</h3><p>This method would accept an <code>interface</code> type and convert it JSON, this allows it to accept <code>createPbResponse</code>,<code>deletePbResponse</code>,<code>getPbResponse</code> as an <code>interface{}</code> and encode it as json using the annotations in the struct definition.</p><pre><code class="language-go">func encodeResponse(_ context.Context, w http.ResponseWriter, response interface{}) error {
    return json.NewEncoder(w).Encode(response)
}
</code></pre><h2 id="main" style="position:relative">Main</h2><pre><code class="language-go">import (
    &quot;context&quot;
    &quot;encoding/json&quot;
    &quot;errors&quot;
    &quot;log&quot;
    &quot;net/http&quot;

    &quot;github.com/go-kit/kit/endpoint&quot;
    &quot;github.com/google/uuid&quot;

    httptransport &quot;github.com/go-kit/kit/transport/http&quot;
)

func main() {
    svc := NewPbService()
    createPbHandler := httptransport.NewServer(
        createPbEndpoint(svc),
        decodeCreatePbRequest,
        encodeResponse,
    )

    deletePbHandler := httptransport.NewServer(
        deletePbEndpoint(svc),
        decodeDeletePbRequest,
        encodeResponse,
    )
    
    getPbHandler := httptransport.NewServer(
        getPbEndpoint(svc),
        decodeGetPbRequest,
        encodeResponse,
    )
    
    http.Handle(&quot;/create&quot;, createPbHandler)
    http.Handle(&quot;/delete&quot;, deletePbHandler)
    http.Handle(&quot;/get&quot;, getPbHandler)
    log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil))
}
</code></pre><h2 id="divide-and-conquer" style="position:relative">Divide and Conquer</h2><p>At this point the <code>main.go</code> has a lot of code so lets move to different files so that we have separation of concerns.</p><h3 id="servicego" style="position:relative"><code>service.go</code></h3><pre><code class="language-go">package main

import (
    &quot;context&quot;
    &quot;errors&quot;

    &quot;github.com/google/uuid&quot;
)

// PbService provides storage capabilities
type PbService interface {
    Create(ctx context.Context, content string) (string, error)
    Delete(ctx context.Context, key string) (string, error)
    Get(ctx context.Context, key string) (string, error)
}

type pbService struct {
    memory map[uuid.UUID]string
}

// NewPbService make a new PbService
func NewPbService() PbService {
    return pbService{
        memory: make(map[uuid.UUID]string),
    }
}

//Create: Here we store the content and return a uuid
func (s pbService) Create(ctx context.Context, content string) (string, error) {
    id := uuid.New()
    s.memory[id] = content
    return id.String(), nil
}

//Get: Here we use the key to find and return the content stored
func (s pbService) Get(ctx context.Context, key string) (string, error) {
    id, err := uuid.Parse(key)
    if err != nil {
        return &quot;&quot;, errors.New(&quot;Invalid Uuid Format&quot;)
    }
    content, exists := s.memory[id]
    if exists {
        return content, nil
    }
    return &quot;&quot;, errors.New(&quot;Invalid Uuid&quot;)
}

//Delete: Here we use the key to find and delete the content stored
func (s pbService) Delete(ctx context.Context, key string) (string, error) {
    id, err := uuid.Parse(key)
    if err != nil {
        return &quot;&quot;, errors.New(&quot;Invalid Uuid Format&quot;)
    }
    delete(s.memory, id)
    return &quot;ok&quot;, nil
}
</code></pre><h3 id="transportgo" style="position:relative"><code>transport.go</code></h3><pre><code class="language-go">package main

import (
    &quot;context&quot;
    &quot;encoding/json&quot;
    &quot;net/http&quot;

    &quot;github.com/go-kit/kit/endpoint&quot;
)

type createPbRequest struct {
    Content string `json:&quot;content&quot;`
}

type createPbResponse struct {
    Key string `json:&quot;key&quot;`
    Err string `json:&quot;err,omitempty&quot;` // errors don&#x27;t JSON-marshal, so we use a string
}

type getPbRequest struct {
    Key string `json:&quot;key&quot;`
}

type getPbResponse struct {
    Content string `json:&quot;content&quot;`
    Err     string `json:&quot;err,omitempty&quot;` // errors don&#x27;t JSON-marshal, so we use a string
}

type deletePbRequest struct {
    Key string `json:&quot;key&quot;`
}

type deletePbResponse struct {
    Status string `json:&quot;status&quot;`
    Err    string `json:&quot;err,omitempty&quot;` // errors don&#x27;t JSON-marshal, so we use a string
}

func createPbEndpoint(svc PbService) endpoint.Endpoint {
    return func(ctx context.Context, request interface{}) (interface{}, error) {
        req := request.(createPbRequest)
        key, err := svc.Create(ctx, req.Content)
        if err != nil {
            return createPbResponse{key, err.Error()}, nil
        }
        return createPbResponse{key, &quot;&quot;}, nil
    }
}

func deletePbEndpoint(svc PbService) endpoint.Endpoint {
    return func(ctx context.Context, request interface{}) (interface{}, error) {
        req := request.(deletePbRequest)
        status, err := svc.Delete(ctx, req.Key)
        if err != nil {
            return deletePbResponse{status, err.Error()}, nil
        }
        return deletePbResponse{status, &quot;&quot;}, nil
    }
}

func getPbEndpoint(svc PbService) endpoint.Endpoint {
    return func(ctx context.Context, request interface{}) (interface{}, error) {
        req := request.(getPbRequest)
        content, err := svc.Get(ctx, req.Key)
        if err != nil {
            return getPbResponse{content, err.Error()}, nil
        }
        return getPbResponse{content, &quot;&quot;}, nil
    }
}

func decodeCreatePbRequest(_ context.Context, r *http.Request) (interface{}, error) {
    var request createPbRequest
    if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil {
        return nil, err
    }
    return request, nil
}

func decodeGetPbRequest(_ context.Context, r *http.Request) (interface{}, error) {
    var request getPbRequest
    if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil {
        return nil, err
    }
    return request, nil
}

func decodeDeletePbRequest(_ context.Context, r *http.Request) (interface{}, error) {
    var request deletePbRequest
    if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil {
        return nil, err
    }
    return request, nil
}
</code></pre><h3 id="maingo" style="position:relative"><code>main.go</code></h3><pre><code class="language-go">func main() {
    svc := NewPbService()
    createPbHandler := httptransport.NewServer(
        createPbEndpoint(svc),
        decodeCreatePbRequest,
        encodeResponse,
    )

    deletePbHandler := httptransport.NewServer(
        deletePbEndpoint(svc),
        decodeDeletePbRequest,
        encodeResponse,
    )
    getPbHandler := httptransport.NewServer(
        getPbEndpoint(svc),
        decodeGetPbRequest,
        encodeResponse,
    )
    http.Handle(&quot;/create&quot;, createPbHandler)
    http.Handle(&quot;/delete&quot;, deletePbHandler)
    http.Handle(&quot;/get&quot;, getPbHandler)
    log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil))
}
</code></pre><h2 id="logging-middleware" style="position:relative">Logging Middleware</h2><p>All applications need to log information, this can be enabled by adding a logging middleware that we create in a file called <code>logging.go</code></p><p>Middleware in go-kit work on <code>Endpoint</code></p><p>The interface definition is <code>type Middleware func(Endpoint) Endpoint</code>, which means it is a function that takes in an endpoint and returns an endpoint</p><p>We can create the <code>loggingMiddleware</code> so that it adheres to the <code>PbService</code> by implementing the <code>Create</code> <code>Delete</code> <code>Get</code> methods.</p><pre><code class="language-go">type loggingMiddleware struct {
    logger log.Logger
    next   PbService
}
</code></pre><h3 id="create" style="position:relative">Create</h3><pre><code class="language-go">func (m loggingMiddleware) Create(ctx context.Context, content string) (output string, err error) {
    // This defered function would be invoked just before the retuen statement
    defer func(begin time.Time) {
        m.logger.Log(
            &quot;method&quot;, &quot;CreatePb&quot;,
            &quot;input&quot;, content,
            &quot;output&quot;, output,
            &quot;err&quot;, err,
            &quot;took&quot;, time.Since(begin),
        )
    }(time.Now())
    output, err = m.next.Create(ctx, content)
    return
}
</code></pre><h3 id="delete" style="position:relative">Delete</h3><pre><code class="language-go"> func (m loggingMiddleware) Delete(ctx context.Context, key string) (output string, err error) {
    defer func(begin time.Time) {
        m.logger.Log(
            &quot;method&quot;, &quot;DeletePb&quot;,
            &quot;input&quot;, key,
            &quot;output&quot;, output,
            &quot;err&quot;, err,
            &quot;took&quot;, time.Since(begin),
        )
    }(time.Now())
    output, err = m.next.Delete(ctx, key)
    return
}
</code></pre><h3 id="get" style="position:relative">Get</h3><pre><code class="language-go">func (m loggingMiddleware) Get(ctx context.Context, key string) (output string, err error) {
    defer func(begin time.Time) {
        m.logger.Log(
            &quot;method&quot;, &quot;GetPb&quot;,
            &quot;input&quot;, key,
            &quot;output&quot;, output,
            &quot;err&quot;, err,
            &quot;took&quot;, time.Since(begin),
        )
    }(time.Now())
    output, err = m.next.Get(ctx, key)
    return
}
</code></pre><h2 id="wiring-the-middleware" style="position:relative">Wiring the Middleware</h2><p>In order to wire the middleware in all we have to do is link it up with the service that we have defined</p><pre><code class="language-go">package main

import (
    &quot;context&quot;
    &quot;encoding/json&quot;
    &quot;net/http&quot;
    &quot;os&quot;

    &quot;github.com/go-kit/kit/log&quot;

    httptransport &quot;github.com/go-kit/kit/transport/http&quot;
)

func main() {
    // Use the global logger
    logger := log.NewLogfmtLogger(os.Stderr)
    var svc PbService
    svc = NewPbService()
    // Wire the middleware and thats it
    svc = loggingMiddleware{logger, svc}

    createPbHandler := httptransport.NewServer(
        createPbEndpoint(svc),
        decodeCreatePbRequest,
        encodeResponse,
    )

    deletePbHandler := httptransport.NewServer(
        deletePbEndpoint(svc),
        decodeDeletePbRequest,
        encodeResponse,
    )

    getPbHandler := httptransport.NewServer(
        getPbEndpoint(svc),
        decodeGetPbRequest,
        encodeResponse,
    )
    http.Handle(&quot;/create&quot;, createPbHandler)
    http.Handle(&quot;/delete&quot;, deletePbHandler)
    http.Handle(&quot;/get&quot;, getPbHandler)
    logger.Log(&quot;msg&quot;, &quot;HTTP&quot;, &quot;addr&quot;, &quot;:8080&quot;)
    logger.Log(&quot;err&quot;, http.ListenAndServe(&quot;:8080&quot;, nil))
}

func encodeResponse(_ context.Context, w http.ResponseWriter, response interface{}) error {
    return json.NewEncoder(w).Encode(response)
}
</code></pre><h2 id="pastebin" style="position:relative">PasteBin</h2><h3 id="client" style="position:relative">Client</h3><pre><code class="language-sh">
$ curl localhost:8080/create -XPOST -d &#x27;{&quot;content&quot;:&quot;THIS IS SPARTA&quot;}&#x27;

{&quot;key&quot;:&quot;c449250a-d74c-4d23-acbb-6785b0bd822a&quot;} 

$ curl localhost:8080/get -XPOST -d &#x27;{&quot;key&quot;:&quot;c449250a-d74c-4d23-acbb-6785b0bd822a&quot;}&#x27;

{&quot;content&quot;:&quot;THIS IS SPARTA&quot;}

$ curl localhost:8I00/delete -XPOST -d &#x27;{&quot;key&quot;:&quot;c449250a-d74c-4d23-acbb-6785b0bd822a&quot;}&#x27;

{&quot;status&quot;:&quot;ok&quot;}

$ curl localhost:8080/get -XPOST -d &#x27;{&quot;key&quot;:&quot;c449250a-d74c-4d23-acbb-6785b0bd822a&quot;}&#x27;

{&quot;content&quot;:&quot;&quot;,&quot;err&quot;:&quot;Invalid Uuid&quot;}

</code></pre><h3 id="server" style="position:relative">Server</h3><pre><code class="language-sh">$ ./pastebin-II 

msg=HTTP addr=:8080

method=CreatePb input=&quot;THIS IS SPARTA&quot; output=c449250a-d74c-4d23-acbb-6785b0bd822a err=null took=67.92µs

method=GetPb input=c449250a-d74c-4d23-acbb-6785b0bd822a output=&quot;THIS IS SPARTA&quot; err=null took=1.675µs

method=DeletePb input=c449250a-d74c-4d23-acbb-6785b0bd822a output=ok err=null took=1.45µs

method=GetPb input=c449250a-d74c-4d23-acbb-6785b0bd822a output= err=&quot;Invalid Uuid&quot; took=803ns
</code></pre><div class="references-block"><h3>Referred in</h3><div><div><a class="reference" href="/foam/golang"><div><h5>Golang</h5></div></a></div></div></div></div><a aria-current="page" class="obstructed-label" href="/foam/gokit">Gokit</a></div></div></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/gokit";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-fd7ae9db326d5475b438.js"],"app":["/app-a23c3f4de5f92c6458ad.js"],"component---node-modules-gatsby-theme-garden-src-templates-local-file-js":["/component---node-modules-gatsby-theme-garden-src-templates-local-file-js-5e093f5807d6eb5ecced.js"]};/*]]>*/</script><script src="/foam/polyfill-fd7ae9db326d5475b438.js" nomodule=""></script><script src="/foam/webpack-runtime-23d80780450712e11cfe.js" async=""></script><script src="/foam/framework-8c8d363c63d1a9a80d21.js" async=""></script><script src="/foam/app-a23c3f4de5f92c6458ad.js" async=""></script><script src="/foam/styles-89fd2ae28bdf06750a71.js" async=""></script><script src="/foam/component---node-modules-gatsby-theme-garden-src-templates-local-file-js-5e093f5807d6eb5ecced.js" async=""></script></body></html>